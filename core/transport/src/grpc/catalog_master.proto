syntax = "proto2";

option java_multiple_files = true;
option java_package = "alluxio.grpc";
option java_outer_classname = "CatalogMasterProto";

package alluxio.grpc;

import "grpc/common.proto";

enum FieldTypeId {
    BOOLEAN = 0;
    INTEGER = 1;
    LONG = 2;
    FLOAT = 3;
    DOUBLE = 4;
    DATE = 5;
    TIME = 6;
    TIMESTAMP = 7;
    STRING = 8;
    UUID = 9;
    FIXED = 10;
    BINARY = 11;
    DECIMAL= 12;
    // the following are composite types, we will support them later
    STRUCT = 13;
    LIST = 14;
    MAP = 15;
}

message Type {
    required FieldTypeId type = 1;
    optional string primitive_field = 2; // parse directly from a string
    repeated FieldSchema nested_fields = 3; //a list of fields for complex types
}

message FieldSchema {
    optional uint32 id = 1;
    optional string name = 2;
    optional Type type = 3;
    optional bool optional = 4;
}

message Schema {
    repeated FieldSchema cols = 1;
}

message Database {
    optional string name = 1;
    optional string description = 2;
    optional string location = 3;
    map<string, string> parameter = 4;
}

enum TableType {
    NATIVE = 0; //native alluxio metastore table, both metadata and datafile managed by alluxio
    IMPORTED = 1; //imported alluxio metastore table, only the metadata is managed by alluxio
}
message TableInfo {
    optional string table_name = 1;
    optional string db_name = 2;
    optional TableType type = 3;
    optional string base_location = 4;
    optional uint32 version = 5;
    optional Schema schema = 6;
}

// Parquet metadata related types
enum Repetition {
    REPEATED = 1;
    OPTIONAL = 2;
    REQUIRED = 3;
}
message FieldType {
    optional Repetition repetition = 1;
    optional string name = 2;
    repeated FieldType fields = 3;
}

message MessageType {
    optional string name = 1;
    repeated FieldType type = 2;
}

message FileMetadata {
    optional MessageType schema = 1;
    map<string, string> key_value_metadata = 2;
    optional string created_by = 3;
}

message ColumnPath {
    repeated string path_segment = 1;
}


enum CompressionCodecName {
    UNCOMPRESSED = 0;
    SNAPPY = 1;
    GZIP = 2;
    LZO = 3;
    BROTLI = 4;
    LZ4 = 5;
    ZSTD = 6;
}

enum Encoding {
    PLAIN = 0;
    RLE = 1;
    BIT_PACKED = 2;
    PLAIN_DICTIONARY = 3;
    DELTA_BINARY_PACKED = 4;
    DELTA_LENGTH_BYTE_ARRAY = 5;
    DELTA_BYTE_ARRAY = 6;
    RLE_DICTIONARY = 7;
}
message ColumnChunkMetaData {
    optional ColumnPath path = 1;
    enum PrimitiveTypeName {
        INT64 = 0;
        INT32 = 1;
        BOOLEAN = 2;
        BINARY = 3;
        FLOAT = 4;
        DOUBLE = 5;
        INT96 = 6;
        FIXED_LEN_BYTE_ARRAY = 7;
    }
    optional PrimitiveTypeName type = 2;
    optional CompressionCodecName codec = 3;
    repeated Encoding encodings = 4;
    optional int64 first_data_page = 5;
    optional int64 page_offset = 6;
    optional int64 value_count = 7;
    optional int64 total_size = 8;
    optional int64 total_uncompressed_size = 9;
}

message BlockMetadata {
    optional int64 row_count = 1;
    optional int64 total_byte_count = 2;
    optional string path = 3;
    repeated ColumnChunkMetaData col_data = 4;
}

message ParquetMetadata {
    optional FileMetadata file_metadata = 1;
    repeated BlockMetadata block_metadata = 2;
}

message PartitionInfo {
  repeated string values = 1; // string value is converted to appropriate partition key type
  optional string dbName = 2;
  optional string tableName = 3;
  optional int32 createTime = 4;
  optional int32 lastAccessTime = 5;
  optional string sd = 6; // storage descriptor
  map<string, string> parameters = 7;
  optional string catName = 9;
  optional int64 writeId = 10;
  optional bool isStatsCompliant = 11;
  optional ColumnStatisticsInfo col_stats = 12; // column statistics for partition
}

message ColumnStatisticsInfo {
    optional string col_name = 1;
    optional FieldTypeId col_type = 2;
    optional ColumnStatisticsData data = 3;
}

message ColumnStatisticsData {
}

message GetAllDatabasesPRequest {
}

message GetAllDatabasesPResponse {
    repeated string database = 1;
}

message GetAllTablesPRequest {
    optional string database = 1;
}

message GetAllTablesPResponse {
    repeated string table = 1;
}

message GetTablePRequest {
    optional string db_name = 1;
    optional string table_name = 2;
}

message GetTablePResponse {
    optional TableInfo table_info = 1;
}

message CreateTablePRequest {
    optional string db_name = 1;
    optional string table_name = 2;
    optional Schema schema = 3;
}

message CreateTablePResponse {
    optional bool success = 1;
    optional TableInfo table_info = 2;
}

message CreateDatabasePRequest {
    optional string db_name = 1;
    map<string, string> options = 2;
}

message CreateDatabasePResponse {
    optional bool success = 1;
}

message GetDataFilesPRequest {
    optional string db_name = 1;
    optional string table_name = 2;
}

message GetDataFilesPResponse {
    repeated string data_file = 1;
}

message GetStatisticsPRequest {
    optional string db_name = 1;
    optional string table_name = 2;
}

message AttachDatabasePRequest {
    optional string db_name = 1;
    optional string db_type = 2;
    map<string, string> options = 3;
}

message AttachDatabasePResponse {
    optional bool success = 1;
}

message ColumnStatistics {
    optional uint64 record_count = 1;
}

message FileStatistics {
    map<string, ColumnStatistics> column = 1; //map column names to column statistics
}

message GetStatisticsPResponse {
    map<string, FileStatistics> statistics = 1;
}

message Value {
    oneof value {
        int64 scala_type = 1;
        float float_type = 2;
        string string_type = 3;
    }
}

message Range {
    optional Value low = 1;
    optional Value high = 2;
}

message RangeSet {
    repeated Range ranges = 1;
}

message EquatableValueSet {
    repeated Value candidates = 1;
}

message AllOrNoneSet {
    optional bool all = 1;
}

message Domain {
    oneof value_set {
        RangeSet range = 1;
        EquatableValueSet equatable = 2;
        AllOrNoneSet all_or_none = 3;
    }
}

message Constraint {
    map<string, Domain> column_constraints = 1; // maps column to constraint, columns not present are not constrained
}

message ReadTablePRequest {
    optional string db_name = 1;
    optional string table_name = 2;
    optional Constraint constraint = 3;
}

message ReadTablePResponse {
    repeated PartitionInfo partitions = 1;
}

/**
 * This interface contains catalog master service endpoints for Alluxio clients.
 */
service CatalogMasterClientService {

    /**
     * Returns all databases in the catalog
     */
    rpc GetAllDatabases(GetAllDatabasesPRequest) returns (GetAllDatabasesPResponse);

    /**
     * Returns all tables in the database
     */
    rpc GetAllTables(GetAllTablesPRequest) returns (GetAllTablesPResponse);

    /**
     * Returns a specific table info
     */
    rpc GetTable(GetTablePRequest) returns (GetTablePResponse);

    /**
     * Create a new table in the metastore
     */
    rpc CreateTable(CreateTablePRequest) returns (CreateTablePResponse);

    /**
     * Create a new database in the metastore
     */
    rpc CreateDatabase(CreateDatabasePRequest) returns (CreateDatabasePResponse);

    /**
     * Attach an existing database into the catalog as a new database name
     */
    rpc AttachDatabase(AttachDatabasePRequest) returns (AttachDatabasePResponse);

    rpc GetStatistics(GetStatisticsPRequest) returns (GetStatisticsPResponse);

    rpc ReadTable(ReadTablePRequest) returns (ReadTablePResponse);
}
