{"version":3,"sources":["../src/createParser.js"],"names":["parse","selector","parser","ParserRules","ParserStart","results","feed","length","Error"],"mappings":";;;;;;AAEA;;AAOA;;;;;;;;;oBATA;;kBAWe,YAAM;AACnB,MAAMA,QAAQ,SAARA,KAAQ,CAACC,QAAD,oEAAsE;AAClF,QAAMC,SAAS,oBAAW,kBAAQC,WAAnB,EAAgC,kBAAQC,WAAxC,CAAf;;AAEA,QAAMC,UAAUH,OAAOI,IAAP,CAAYL,QAAZ,EAAsBI,OAAtC;;AAEA,QAAIA,QAAQE,MAAR,KAAmB,CAAvB,EAA0B;AACxB,YAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACD;;AAED,QAAIH,QAAQE,MAAR,GAAiB,CAArB,EAAwB;AACtB,YAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACD;;AAED,WAAOH,QAAQ,CAAR,CAAP;AACD,GAdD;;AAgBA,SAAO;AACLL;AADK,GAAP;AAGD,C","file":"createParser.js","sourcesContent":["// @flow\n\nimport {\n  Parser\n} from 'nearley';\nimport type {\n  CombinatorTokenType,\n  SelectorTokenType\n} from './types';\nimport grammar from './grammar';\n\nexport default () => {\n  const parse = (selector: string): Array<SelectorTokenType | CombinatorTokenType> => {\n    const parser = new Parser(grammar.ParserRules, grammar.ParserStart);\n\n    const results = parser.feed(selector).results;\n\n    if (results.length === 0) {\n      throw new Error('Found no parsings.');\n    }\n\n    if (results.length > 1) {\n      throw new Error('Ambiguous results.');\n    }\n\n    return results[0];\n  };\n\n  return {\n    parse\n  };\n};\n"]}