{"version":3,"file":"immer.js","sources":["../src/common.js","../src/patches.js","../src/es5.js","../src/proxy.js","../src/immer.js","../src/index.js"],"sourcesContent":["export const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const DRAFT_STATE =\n    typeof Symbol !== \"undefined\" ? Symbol(\"immer-state\") : \"__$immer_state\"\n\nexport function isDraft(value) {\n    return !!value && !!value[DRAFT_STATE]\n}\n\nexport function isDraftable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function original(value) {\n    if (value && value[DRAFT_STATE]) {\n        return value[DRAFT_STATE].base\n    }\n    // otherwise return undefined\n}\n\nexport const assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i], value)\n    } else {\n        for (let key in value) cb(key, value[key], value)\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","import {each} from \"./common\"\n\nexport function generatePatches(state, basePath, patches, inversePatches) {\n    Array.isArray(state.base)\n        ? generateArrayPatches(state, basePath, patches, inversePatches)\n        : generateObjectPatches(state, basePath, patches, inversePatches)\n}\n\nexport function generateArrayPatches(state, basePath, patches, inversePatches) {\n    const {base, copy, assigned} = state\n    const minLength = Math.min(base.length, copy.length)\n\n    // Look for replaced indices.\n    for (let i = 0; i < minLength; i++) {\n        if (assigned[i] && base[i] !== copy[i]) {\n            const path = basePath.concat(i)\n            patches.push({op: \"replace\", path, value: copy[i]})\n            inversePatches.push({op: \"replace\", path, value: base[i]})\n        }\n    }\n\n    // Did the array expand?\n    if (minLength < copy.length) {\n        for (let i = minLength; i < copy.length; i++) {\n            patches.push({\n                op: \"add\",\n                path: basePath.concat(i),\n                value: copy[i]\n            })\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basePath.concat(\"length\"),\n            value: base.length\n        })\n    }\n\n    // ...or did it shrink?\n    else if (minLength < base.length) {\n        patches.push({\n            op: \"replace\",\n            path: basePath.concat(\"length\"),\n            value: copy.length\n        })\n        for (let i = minLength; i < base.length; i++) {\n            inversePatches.push({\n                op: \"add\",\n                path: basePath.concat(i),\n                value: base[i]\n            })\n        }\n    }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n    const {base, copy} = state\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = base[key]\n        const value = copy[key]\n        const op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\"\n        if (origValue === base && op === \"replace\") return\n        const path = basePath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                ? {op: \"add\", path, value: origValue}\n                : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        const {path} = patch\n        if (path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            let base = draft\n            for (let i = 0; i < path.length - 1; i++) {\n                base = base[path[i]]\n                if (!base || typeof base !== \"object\")\n                    throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n            }\n            const key = path[path.length - 1]\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key !== base.length - 1)\n                            throw new Error(`Only the last index of an array can be removed, index: ${key}, length: ${base.length}`) // prettier-ignore\n                        base.length -= 1\n                    } else {\n                        delete base[key]\n                    }\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\n\nconst descriptors = {}\n\n// For nested produce calls:\nexport const scopes = []\nexport const currentScope = () => scopes[scopes.length - 1]\n\nexport function willFinalize(result, baseDraft, needPatches) {\n    const scope = currentScope()\n    scope.forEach(state => (state.finalizing = true))\n    if (result === undefined || result === baseDraft) {\n        if (needPatches) markChangesRecursively(baseDraft)\n        // This is faster when we don't care about which attributes changed.\n        markChangesSweep(scope)\n    }\n}\n\nexport function createDraft(base, parent) {\n    let draft\n    if (isDraft(base)) {\n        const state = base[DRAFT_STATE]\n        // Avoid creating new drafts when copying.\n        state.finalizing = true\n        draft = shallowCopy(state.draft)\n        state.finalizing = false\n    } else {\n        draft = shallowCopy(base)\n    }\n    each(base, prop => {\n        Object.defineProperty(draft, \"\" + prop, createPropertyProxy(\"\" + prop))\n    })\n\n    // See \"proxy.js\" for property documentation.\n    const state = {\n        scope: parent ? parent.scope : currentScope(),\n        modified: false,\n        finalizing: false, // es5 only\n        finalized: false,\n        assigned: {},\n        parent,\n        base,\n        draft,\n        copy: null,\n        revoke,\n        revoked: false // es5 only\n    }\n\n    createHiddenProperty(draft, DRAFT_STATE, state)\n    state.scope.push(state)\n    return draft\n}\n\nfunction revoke() {\n    this.revoked = true\n}\n\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    assertUnrevoked(state)\n    const value = source(state)[prop]\n    // Drafts are only created for proxyable values that exist in the base state.\n    if (!state.finalizing && value === state.base[prop] && isDraftable(value)) {\n        prepareCopy(state)\n        return (state.copy[prop] = createDraft(value, state))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnrevoked(state)\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (!state.copy) state.copy = shallowCopy(state.base)\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[DRAFT_STATE], prop)\n            },\n            set(value) {\n                set(this[DRAFT_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnrevoked(state) {\n    if (state.revoked === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(scope) {\n    // The natural order of drafts in the `scope` array is based on when they\n    // were accessed. By processing drafts in reverse natural order, we have a\n    // better chance of processing leaf nodes first. When a leaf node is known to\n    // have changed, we can avoid any traversal of its ancestor nodes.\n    for (let i = scope.length - 1; i >= 0; i--) {\n        const state = scope[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[DRAFT_STATE]\n    if (!state) return\n    const {base, draft, assigned} = state\n    if (!Array.isArray(object)) {\n        // Look for added keys.\n        Object.keys(draft).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (base[key] === undefined && !has(base, key)) {\n                assigned[key] = true\n                markChanged(state)\n            } else if (!assigned[key]) {\n                // Only untouched properties trigger recursion.\n                markChangesRecursively(draft[key])\n            }\n        })\n        // Look for removed keys.\n        Object.keys(base).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (draft[key] === undefined && !has(draft, key)) {\n                assigned[key] = false\n                markChanged(state)\n            }\n        })\n    } else if (hasArrayChanges(state)) {\n        markChanged(state)\n        assigned.length = true\n        if (draft.length < base.length) {\n            for (let i = draft.length; i < base.length; i++) assigned[i] = false\n        } else {\n            for (let i = base.length; i < draft.length; i++) assigned[i] = true\n        }\n        for (let i = 0; i < draft.length; i++) {\n            // Only untouched indices trigger recursion.\n            if (assigned[i] === undefined) markChangesRecursively(draft[i])\n        }\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const {base, draft} = state\n\n    // Search for added keys. Start at the back, because non-numeric keys\n    // are ordered by time of definition on the object.\n    const keys = Object.keys(draft)\n    for (let i = keys.length - 1; i >= 0; i--) {\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (base[keys[i]] === undefined && !has(base, keys[i])) {\n            return true\n        }\n    }\n\n    // Since no keys have been added, we can compare lengths to know if an\n    // object has been deleted.\n    return keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state) {\n    const {draft} = state\n    if (draft.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraftable,\n    isDraft,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\n\n// For nested produce calls:\nexport const scopes = []\nexport const currentScope = () => scopes[scopes.length - 1]\n\n// Do nothing before being finalized.\nexport function willFinalize() {}\n\nexport function createDraft(base, parent) {\n    const state = {\n        // Track which produce call this is associated with.\n        scope: parent ? parent.scope : currentScope(),\n        // True for both shallow and deep changes.\n        modified: false,\n        // Used during finalization.\n        finalized: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned: {},\n        // The parent draft state.\n        parent,\n        // The base state.\n        base,\n        // The base proxy.\n        draft: null,\n        // Any property proxies.\n        drafts: {},\n        // The base copy with any updated values.\n        copy: null,\n        // Called by the `produce` function.\n        revoke: null\n    }\n\n    const {revoke, proxy} = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n\n    state.draft = proxy\n    state.revoke = revoke\n\n    state.scope.push(state)\n    return proxy\n}\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support deleting properties from arrays: \" + prop\n        )\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support setting non-numeric properties on arrays: \" +\n                prop\n        )\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    if (prop === DRAFT_STATE) return state\n    let {drafts} = state\n\n    // Check for existing draft in unmodified state.\n    if (!state.modified && has(drafts, prop)) {\n        return drafts[prop]\n    }\n\n    const value = source(state)[prop]\n    if (state.finalized || !isDraftable(value)) return value\n\n    // Check for existing draft in modified state.\n    if (state.modified) {\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value !== state.base[prop]) return value\n        // Store drafts on the copy (when one exists).\n        drafts = state.copy\n    }\n\n    return (drafts[prop] = createDraft(value, state))\n}\n\nfunction set(state, prop, value) {\n    if (!state.modified) {\n        // Optimize based on value's truthiness. Truthy values are guaranteed to\n        // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n        // values may be drafts, but falsy values are never drafts.\n        const isUnchanged = value\n            ? is(state.base[prop], value) || value === state.drafts[prop]\n            : is(state.base[prop], value) && prop in state.base\n        if (isUnchanged) return true\n        markChanged(state)\n    }\n    state.assigned[prop] = true\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (state.base[prop] !== undefined || prop in state.base) {\n        state.assigned[prop] = false\n        markChanged(state)\n    }\n    if (state.copy) delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.drafts, prop)\n        ? state.drafts\n        : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = assign(shallowCopy(state.base), state.drafts)\n        state.drafts = null\n        if (state.parent) markChanged(state.parent)\n    }\n}\n","import * as legacyProxy from \"./es5\"\nimport * as modernProxy from \"./proxy\"\nimport {generatePatches} from \"./patches\"\nimport {\n    assign,\n    each,\n    is,\n    isDraft,\n    isDraftable,\n    shallowCopy,\n    DRAFT_STATE,\n    NOTHING\n} from \"./common\"\n\nfunction verifyMinified() {}\n\nconst configDefaults = {\n    useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n    autoFreeze:\n        typeof process !== \"undefined\"\n            ? process.env.NODE_ENV !== \"production\"\n            : verifyMinified.name === \"verifyMinified\",\n    onAssign: null,\n    onDelete: null,\n    onCopy: null\n}\n\nexport class Immer {\n    constructor(config) {\n        assign(this, configDefaults, config)\n        this.setUseProxies(this.useProxies)\n        this.produce = this.produce.bind(this)\n    }\n    produce(base, recipe, patchListener) {\n        // curried invocation\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\n            const defaultBase = recipe\n            recipe = base\n\n            // prettier-ignore\n            return (base = defaultBase, ...args) =>\n                this.produce(base, draft => recipe.call(draft, draft, ...args))\n        }\n\n        // prettier-ignore\n        {\n            if (typeof recipe !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n            if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n        }\n\n        let result\n        // Only create proxies for plain objects/arrays.\n        if (!isDraftable(base)) {\n            result = recipe(base)\n            if (result === undefined) return base\n        }\n        // See #100, don't nest producers\n        else if (isDraft(base)) {\n            result = recipe.call(base, base)\n            if (result === undefined) return base\n        }\n        // The given value must be proxied.\n        else {\n            this.scopes.push([])\n            const baseDraft = this.createDraft(base)\n            try {\n                result = recipe.call(baseDraft, baseDraft)\n                this.willFinalize(result, baseDraft, !!patchListener)\n\n                // Never generate patches when no listener exists.\n                var patches = patchListener && [],\n                    inversePatches = patchListener && []\n\n                // Finalize the modified draft...\n                if (result === undefined || result === baseDraft) {\n                    result = this.finalize(\n                        baseDraft,\n                        [],\n                        patches,\n                        inversePatches\n                    )\n                }\n                // ...or use a replacement value.\n                else {\n                    // Users must never modify the draft _and_ return something else.\n                    if (baseDraft[DRAFT_STATE].modified)\n                        throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n\n                    // Finalize the replacement in case it contains (or is) a subset of the draft.\n                    if (isDraftable(result)) result = this.finalize(result)\n\n                    if (patchListener) {\n                        patches.push({\n                            op: \"replace\",\n                            path: [],\n                            value: result\n                        })\n                        inversePatches.push({\n                            op: \"replace\",\n                            path: [],\n                            value: base\n                        })\n                    }\n                }\n            } finally {\n                this.currentScope().forEach(state => state.revoke())\n                this.scopes.pop()\n            }\n            patchListener && patchListener(patches, inversePatches)\n        }\n        // Normalize the result.\n        return result === NOTHING ? undefined : result\n    }\n    setAutoFreeze(value) {\n        this.autoFreeze = value\n    }\n    setUseProxies(value) {\n        this.useProxies = value\n        assign(this, value ? modernProxy : legacyProxy)\n    }\n    /**\n     * @internal\n     * Finalize a draft, returning either the unmodified base state or a modified\n     * copy of the base state.\n     */\n    finalize(draft, path, patches, inversePatches) {\n        const state = draft[DRAFT_STATE]\n        if (!state) {\n            if (Object.isFrozen(draft)) return draft\n            return this.finalizeTree(draft)\n        }\n        // Never finalize drafts owned by an outer scope.\n        if (state.scope !== this.currentScope()) {\n            return draft\n        }\n        if (!state.modified) return state.base\n        if (!state.finalized) {\n            state.finalized = true\n            this.finalizeTree(state.draft, path, patches, inversePatches)\n            if (this.onDelete) {\n                const {assigned} = state\n                for (const prop in assigned)\n                    assigned[prop] || this.onDelete(state, prop)\n            }\n            if (this.onCopy) this.onCopy(state)\n\n            // Nested producers must never auto-freeze their result,\n            // because it may contain drafts from parent producers.\n            if (this.autoFreeze && this.scopes.length === 1) {\n                Object.freeze(state.copy)\n            }\n\n            if (patches) generatePatches(state, path, patches, inversePatches)\n        }\n        return state.copy\n    }\n    /**\n     * @internal\n     * Finalize all drafts in the given state tree.\n     */\n    finalizeTree(root, path, patches, inversePatches) {\n        const state = root[DRAFT_STATE]\n        if (state) {\n            root = this.useProxies\n                ? state.copy\n                : (state.copy = shallowCopy(state.draft))\n        }\n\n        const {onAssign} = this\n        const finalizeProperty = (prop, value, parent) => {\n            // Only `root` can be a draft in here.\n            const inDraft = !!state && parent === root\n\n            if (isDraft(value)) {\n                // prettier-ignore\n                parent[prop] = value =\n                    // Patches are never generated for assigned properties.\n                    patches && inDraft && !state.assigned[prop]\n                        ? this.finalize(value, path.concat(prop), patches, inversePatches)\n                        : this.finalize(value)\n\n                // Unchanged drafts are ignored.\n                if (inDraft && value === state.base[prop]) return\n            }\n            // Unchanged draft properties are ignored.\n            else if (inDraft && is(value, state.base[prop])) {\n                return\n            }\n            // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n            else if (isDraftable(value) && !Object.isFrozen(value)) {\n                each(value, finalizeProperty)\n            }\n\n            if (inDraft && onAssign) {\n                onAssign(state, prop, value)\n            }\n        }\n\n        each(root, finalizeProperty)\n        return root\n    }\n}\n","import {applyPatches as applyPatchesImpl} from \"./patches\"\nimport {Immer} from \"./immer\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce = immer.produce\nexport default produce\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = value => immer.setAutoFreeze(value)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = value => immer.setUseProxies(value)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = produce(applyPatchesImpl)\n\nexport {original, isDraft, NOTHING as nothing} from \"./common\"\n\nexport {Immer}\n"],"names":["NOTHING","Symbol","DRAFT_STATE","isDraft","value","isDraftable","Array","isArray","proto","Object","getPrototypeOf","prototype","original","base","assign","target","key","has","shallowCopy","slice","__proto__","undefined","create","each","cb","i","length","thing","prop","hasOwnProperty","call","is","x","y","generatePatches","state","basePath","patches","inversePatches","generateArrayPatches","generateObjectPatches","copy","assigned","minLength","Math","min","path","concat","push","op","assignedValue","origValue","applyPatches","draft","patch","Error","join","descriptors","scopes","currentScope","willFinalize","result","baseDraft","needPatches","scope","forEach","finalizing","markChangesRecursively","createDraft","parent","defineProperty","createPropertyProxy","revoke","revoked","source","get","set","modified","markChanged","prepareCopy","assertUnrevoked","JSON","stringify","markChangesSweep","hasArrayChanges","hasObjectChanges","object","keys","descriptor","getOwnPropertyDescriptor","createHiddenProperty","Proxy","revocable","arrayTraps","objectTraps","proxy","Reflect","ownKeys","fn","arguments","apply","deleteProperty","isNaN","parseInt","drafts","finalized","isUnchanged","owner","configurable","verifyMinified","configDefaults","process","env","NODE_ENV","name","Immer","config","setUseProxies","useProxies","produce","bind","recipe","patchListener","defaultBase","args","finalize","pop","autoFreeze","modernProxy","legacyProxy","isFrozen","finalizeTree","onDelete","onCopy","freeze","root","onAssign","finalizeProperty","inDraft","immer","setAutoFreeze","applyPatchesImpl"],"mappings":"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"}