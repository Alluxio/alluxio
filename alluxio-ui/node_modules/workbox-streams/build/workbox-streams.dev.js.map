{"version":3,"names":[],"mappings":"","sources":["packages/workbox-streams/browser.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.streams = (function (exports,logger_mjs,assert_mjs) {\n  'use strict';\n\n  try {\n    self.workbox.v['workbox:streams:3.6.3'] = 1;\n  } catch (e) {} // eslint-disable-line\n\n  /*\n   Copyright 2018 Google Inc. All Rights Reserved.\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n  */\n\n  /**\n   * Takes either a Response, a ReadableStream, or a\n   * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n   * ReadableStreamReader object associated with it.\n   *\n   * @param {workbox.streams.StreamSource} source\n   * @return {ReadableStreamReader}\n   * @private\n   */\n  function _getReaderFromSource(source) {\n    if (source.body && source.body.getReader) {\n      return source.body.getReader();\n    }\n\n    if (source.getReader) {\n      return source.getReader();\n    }\n\n    // TODO: This should be possible to do by constructing a ReadableStream, but\n    // I can't get it to work. As a hack, construct a new Response, and use the\n    // reader associated with its body.\n    return new Response(source).body.getReader();\n  }\n\n  /**\n   * Takes multiple source Promises, each of which could resolve to a Response, a\n   * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n   *\n   * Returns an object exposing a ReadableStream with each individual stream's\n   * data returned in sequence, along with a Promise which signals when the\n   * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n   *\n   * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n   * @return {Object<{done: Promise, stream: ReadableStream}>}\n   *\n   * @memberof workbox.streams\n   */\n  function concatenate(sourcePromises) {\n    {\n      assert_mjs.assert.isArray(sourcePromises, {\n        moduleName: 'workbox-streams',\n        funcName: 'concatenate',\n        paramName: 'sourcePromises'\n      });\n    }\n\n    const readerPromises = sourcePromises.map(sourcePromise => {\n      return Promise.resolve(sourcePromise).then(source => {\n        return _getReaderFromSource(source);\n      });\n    });\n\n    let fullyStreamedResolve;\n    let fullyStreamedReject;\n    const done = new Promise((resolve, reject) => {\n      fullyStreamedResolve = resolve;\n      fullyStreamedReject = reject;\n    });\n\n    let i = 0;\n    const logMessages = [];\n    const stream = new ReadableStream({\n      pull(controller) {\n        return readerPromises[i].then(reader => reader.read()).then(result => {\n          if (result.done) {\n            {\n              logMessages.push(['Reached the end of source:', sourcePromises[i]]);\n            }\n\n            i++;\n            if (i >= readerPromises.length) {\n              // Log all the messages in the group at once in a single group.\n              {\n                logger_mjs.logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n                for (const message of logMessages) {\n                  if (Array.isArray(message)) {\n                    logger_mjs.logger.log(...message);\n                  } else {\n                    logger_mjs.logger.log(message);\n                  }\n                }\n                logger_mjs.logger.log('Finished reading all sources.');\n                logger_mjs.logger.groupEnd();\n              }\n\n              controller.close();\n              fullyStreamedResolve();\n              return;\n            }\n\n            return this.pull(controller);\n          } else {\n            controller.enqueue(result.value);\n          }\n        }).catch(error => {\n          {\n            logger_mjs.logger.error('An error occurred:', error);\n          }\n          fullyStreamedReject(error);\n          throw error;\n        });\n      },\n\n      cancel() {\n        {\n          logger_mjs.logger.warn('The ReadableStream was cancelled.');\n        }\n\n        fullyStreamedResolve();\n      }\n    });\n\n    return { done, stream };\n  }\n\n  /*\n   Copyright 2018 Google Inc. All Rights Reserved.\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n  */\n\n  /**\n   * This is a utility method that determines whether the current browser supports\n   * the features required to create streamed responses. Currently, it checks if\n   * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n   * is available.\n   *\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {boolean} `true`, if the current browser meets the requirements for\n   * streaming responses, and `false` otherwise.\n   *\n   * @memberof workbox.streams\n   */\n  function createHeaders(headersInit = {}) {\n    // See https://github.com/GoogleChrome/workbox/issues/1461\n    const headers = new Headers(headersInit);\n    if (!headers.has('content-type')) {\n      headers.set('content-type', 'text/html');\n    }\n    return headers;\n  }\n\n  /*\n   Copyright 2018 Google Inc. All Rights Reserved.\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n  */\n\n  /**\n   * Takes multiple source Promises, each of which could resolve to a Response, a\n   * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n   * along with a\n   * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n   *\n   * Returns an object exposing a Response whose body consists of each individual\n   * stream's data returned in sequence, along with a Promise which signals when\n   * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n   *\n   * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {Object<{done: Promise, response: Response}>}\n   *\n   * @memberof workbox.streams\n   */\n  function concatenateToResponse(sourcePromises, headersInit) {\n    const { done, stream } = concatenate(sourcePromises);\n\n    const headers = createHeaders(headersInit);\n    const response = new Response(stream, { headers });\n\n    return { done, response };\n  }\n\n  /*\n   Copyright 2018 Google Inc. All Rights Reserved.\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n  */\n\n  let cachedIsSupported = undefined;\n\n  /**\n   * This is a utility method that determines whether the current browser supports\n   * the features required to create streamed responses. Currently, it checks if\n   * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n   * can be created.\n   *\n   * @return {boolean} `true`, if the current browser meets the requirements for\n   * streaming responses, and `false` otherwise.\n   *\n   * @memberof workbox.streams\n   */\n  function isSupported() {\n    if (cachedIsSupported === undefined) {\n      // See https://github.com/GoogleChrome/workbox/issues/1473\n      try {\n        new ReadableStream({ start() {} });\n        cachedIsSupported = true;\n      } catch (error) {\n        cachedIsSupported = false;\n      }\n    }\n\n    return cachedIsSupported;\n  }\n\n  /*\n   Copyright 2018 Google Inc. All Rights Reserved.\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n  */\n\n  /**\n   * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n   *\n   * On browsers that do not support constructing new `ReadableStream`s, this\n   * strategy will automatically wait for all the `sourceFunctions` to complete,\n   * and create a final response that concatenates their values together.\n   *\n   * @param {\n   *   Array<function(workbox.routing.Route~handlerCallback)>} sourceFunctions\n   * Each function should return a {@link workbox.streams.StreamSource} (or a\n   * Promise which resolves to one).\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {workbox.routing.Route~handlerCallback}\n   *\n   * @memberof workbox.streams\n   */\n  function strategy(sourceFunctions, headersInit) {\n    return (() => {\n      var _ref = babelHelpers.asyncToGenerator(function* ({ event, url, params }) {\n        if (isSupported()) {\n          const { done, response } = concatenateToResponse(sourceFunctions.map(function (sourceFunction) {\n            return sourceFunction({ event, url, params });\n          }), headersInit);\n          event.waitUntil(done);\n          return response;\n        }\n\n        {\n          logger_mjs.logger.log(`The current browser doesn't support creating response ` + `streams. Falling back to non-streaming response instead.`);\n        }\n\n        // Fallback to waiting for everything to finish, and concatenating the\n        // responses.\n        const parts = yield Promise.all(sourceFunctions.map(function (sourceFunction) {\n          return sourceFunction({ event, url, params });\n        }).map((() => {\n          var _ref2 = babelHelpers.asyncToGenerator(function* (responsePromise) {\n            const response = yield responsePromise;\n            if (response instanceof Response) {\n              return response.blob();\n            }\n\n            // Otherwise, assume it's something like a string which can be used\n            // as-is when constructing the final composite blob.\n            return response;\n          });\n\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        })()));\n\n        const headers = createHeaders(headersInit);\n        // Constructing a new Response from a Blob source is well-supported.\n        // So is constructing a new Blob from multiple source Blobs or strings.\n        return new Response(new Blob(parts), { headers });\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    })();\n  }\n\n  /*\n    Copyright 2018 Google Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n  */\n\n  /*\n    Copyright 2018 Google Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n  */\n\n  exports.concatenate = concatenate;\n  exports.concatenateToResponse = concatenateToResponse;\n  exports.isSupported = isSupported;\n  exports.strategy = strategy;\n\n  return exports;\n\n}({},workbox.core._private,workbox.core._private));\n"],"file":"workbox-streams.dev.js"}