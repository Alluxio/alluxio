<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Mon Apr 16 12:05:23 UTC 2018 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Apache Hadoop YARN Common 2.9.1"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet org.apache.hadoop.classification.tools.IncludePublicAnnotationsJDiffDoclet -docletpath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/hadoop-annotations.jar:/build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/jdiff.jar -verbose -classpath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/classes:/build/source/hadoop-common-project/hadoop-common/target/hadoop-common-2.9.1.jar:/maven/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar:/maven/xmlenc/xmlenc/0.52/xmlenc-0.52.jar:/maven/org/apache/httpcomponents/httpclient/4.5.2/httpclient-4.5.2.jar:/maven/org/apache/httpcomponents/httpcore/4.4.4/httpcore-4.4.4.jar:/maven/commons-net/commons-net/3.1/commons-net-3.1.jar:/maven/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/maven/org/mortbay/jetty/jetty/6.1.26/jetty-6.1.26.jar:/maven/org/mortbay/jetty/jetty-sslengine/6.1.26/jetty-sslengine-6.1.26.jar:/maven/javax/servlet/jsp/jsp-api/2.1/jsp-api-2.1.jar:/maven/net/java/dev/jets3t/jets3t/0.9.0/jets3t-0.9.0.jar:/maven/com/jamesmurty/utils/java-xmlbuilder/0.4/java-xmlbuilder-0.4.jar:/maven/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jar:/maven/commons-digester/commons-digester/1.8/commons-digester-1.8.jar:/maven/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jar:/maven/commons-beanutils/commons-beanutils-core/1.8.0/commons-beanutils-core-1.8.0.jar:/maven/org/apache/commons/commons-lang3/3.4/commons-lang3-3.4.jar:/maven/org/slf4j/slf4j-log4j12/1.7.25/slf4j-log4j12-1.7.25.jar:/maven/org/apache/avro/avro/1.7.7/avro-1.7.7.jar:/maven/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/maven/org/xerial/snappy/snappy-java/1.0.5/snappy-java-1.0.5.jar:/maven/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar:/build/source/hadoop-common-project/hadoop-auth/target/hadoop-auth-2.9.1.jar:/maven/com/nimbusds/nimbus-jose-jwt/4.41.1/nimbus-jose-jwt-4.41.1.jar:/maven/com/github/stephenc/jcip/jcip-annotations/1.0-1/jcip-annotations-1.0-1.jar:/maven/net/minidev/json-smart/1.3.1/json-smart-1.3.1.jar:/maven/org/apache/directory/server/apacheds-kerberos-codec/2.0.0-M15/apacheds-kerberos-codec-2.0.0-M15.jar:/maven/org/apache/directory/server/apacheds-i18n/2.0.0-M15/apacheds-i18n-2.0.0-M15.jar:/maven/org/apache/directory/api/api-asn1-api/1.0.0-M20/api-asn1-api-1.0.0-M20.jar:/maven/org/apache/directory/api/api-util/1.0.0-M20/api-util-1.0.0-M20.jar:/maven/org/apache/curator/curator-framework/2.7.1/curator-framework-2.7.1.jar:/maven/com/jcraft/jsch/0.1.54/jsch-0.1.54.jar:/maven/org/apache/curator/curator-client/2.7.1/curator-client-2.7.1.jar:/maven/org/apache/curator/curator-recipes/2.7.1/curator-recipes-2.7.1.jar:/maven/com/google/code/findbugs/jsr305/3.0.0/jsr305-3.0.0.jar:/maven/org/apache/htrace/htrace-core4/4.1.0-incubating/htrace-core4-4.1.0-incubating.jar:/maven/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar:/maven/io/netty/netty/3.6.2.Final/netty-3.6.2.Final.jar:/maven/org/codehaus/woodstox/stax2-api/3.1.4/stax2-api-3.1.4.jar:/maven/com/fasterxml/woodstox/woodstox-core/5.0.3/woodstox-core-5.0.3.jar:/build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/target/hadoop-yarn-api-2.9.1.jar:/maven/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jar:/maven/javax/xml/stream/stax-api/1.0-2/stax-api-1.0-2.jar:/maven/javax/activation/activation/1.1/activation-1.1.jar:/maven/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jar:/maven/org/tukaani/xz/1.0/xz-1.0.jar:/maven/commons-lang/commons-lang/2.6/commons-lang-2.6.jar:/maven/javax/servlet/servlet-api/2.5/servlet-api-2.5.jar:/maven/commons-codec/commons-codec/1.4/commons-codec-1.4.jar:/maven/org/mortbay/jetty/jetty-util/6.1.26/jetty-util-6.1.26.jar:/maven/com/sun/jersey/jersey-core/1.9/jersey-core-1.9.jar:/maven/com/sun/jersey/jersey-client/1.9/jersey-client-1.9.jar:/maven/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/maven/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/maven/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jar:/maven/org/codehaus/jackson/jackson-xc/1.9.13/jackson-xc-1.9.13.jar:/maven/com/google/guava/guava/11.0.2/guava-11.0.2.jar:/maven/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/maven/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/maven/org/slf4j/slf4j-api/1.7.25/slf4j-api-1.7.25.jar:/build/source/hadoop-common-project/hadoop-annotations/target/hadoop-annotations-2.9.1.jar:/usr/lib/jvm/java-7-openjdk-amd64/lib/tools.jar:/maven/com/google/inject/extensions/guice-servlet/3.0/guice-servlet-3.0.jar:/maven/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/maven/commons-io/commons-io/2.4/commons-io-2.4.jar:/maven/com/google/inject/guice/3.0/guice-3.0.jar:/maven/javax/inject/javax.inject/1/javax.inject-1.jar:/maven/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/maven/com/sun/jersey/jersey-server/1.9/jersey-server-1.9.jar:/maven/asm/asm/3.2/asm-3.2.jar:/maven/com/sun/jersey/jersey-json/1.9/jersey-json-1.9.jar:/maven/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar:/maven/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/maven/com/sun/jersey/contribs/jersey-guice/1.9/jersey-guice-1.9.jar:/maven/log4j/log4j/1.2.17/log4j-1.2.17.jar -sourcepath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java -apidir /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/site/jdiff/xml -apiname Apache Hadoop YARN Common 2.9.1 -->
<package name="org.apache.hadoop.yarn">
  <!-- start class org.apache.hadoop.yarn.ContainerLogAppender -->
  <class name="ContainerLogAppender" extends="org.apache.log4j.FileAppender"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <constructor name="ContainerLogAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="activateOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.apache.log4j.spi.LoggingEvent"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContainerLogDir" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Getter/Setter methods for log4j.]]>
      </doc>
    </method>
    <method name="setContainerLogDir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerLogDir" type="java.lang.String"/>
    </method>
    <method name="getContainerLogFile" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setContainerLogFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerLogFile" type="java.lang.String"/>
    </method>
    <method name="getTotalLogFileSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTotalLogFileSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="logSize" type="long"/>
    </method>
    <doc>
    <![CDATA[A simple log4j-appender for container's logs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.ContainerLogAppender -->
  <!-- start class org.apache.hadoop.yarn.ContainerRollingLogAppender -->
  <class name="ContainerRollingLogAppender" extends="org.apache.log4j.RollingFileAppender"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <constructor name="ContainerRollingLogAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="activateOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContainerLogDir" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Getter/Setter methods for log4j.]]>
      </doc>
    </method>
    <method name="setContainerLogDir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerLogDir" type="java.lang.String"/>
    </method>
    <method name="getContainerLogFile" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setContainerLogFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerLogFile" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A simple log4j-appender for container's logs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.ContainerRollingLogAppender -->
  <!-- start class org.apache.hadoop.yarn.YarnUncaughtExceptionHandler -->
  <class name="YarnUncaughtExceptionHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Thread.UncaughtExceptionHandler"/>
    <constructor name="YarnUncaughtExceptionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="uncaughtException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Thread"/>
      <param name="e" type="java.lang.Throwable"/>
    </method>
    <doc>
    <![CDATA[This class is intended to be installed by calling 
 {@link Thread#setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler)}
 In the main entry point.  It is intended to try and cleanly shut down
 programs using the Yarn Event framework.
 
 Note: Right now it only will shut down the program if a Error is caught, but
 not any other exception.  Anything else is just logged.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.YarnUncaughtExceptionHandler -->
</package>
<package name="org.apache.hadoop.yarn.api">
</package>
<package name="org.apache.hadoop.yarn.client">
  <!-- start class org.apache.hadoop.yarn.client.AHSProxy -->
  <class name="AHSProxy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AHSProxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createAHSProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="ahsAddress" type="java.net.InetSocketAddress"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="rmAddress" type="java.net.InetSocketAddress"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.AHSProxy -->
  <!-- start class org.apache.hadoop.yarn.client.ClientRMProxy -->
  <class name="ClientRMProxy" extends="org.apache.hadoop.yarn.client.RMProxy"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createRMProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configuration" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a proxy to the ResourceManager for the specified protocol.
 @param configuration Configuration with all the required information.
 @param protocol Client protocol for which proxy is being requested.
 @param <T> Type of proxy.
 @return Proxy to the ResourceManager for the specified client protocol.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getRMDelegationTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the token service name to be used for RMDelegationToken. Depending
 on whether HA is enabled or not, this method generates the appropriate
 service name as a comma-separated list of service addresses.

 @param conf Configuration corresponding to the cluster we need the
             RMDelegationToken for
 @return - Service name for RMDelegationToken]]>
      </doc>
    </method>
    <method name="getAMRMTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="address" type="java.lang.String"/>
      <param name="defaultAddr" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.ClientRMProxy -->
  <!-- start class org.apache.hadoop.yarn.client.NMProxy -->
  <class name="NMProxy" extends="org.apache.hadoop.yarn.client.ServerProxy"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMProxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createNMProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="rpc" type="org.apache.hadoop.yarn.ipc.YarnRPC"/>
      <param name="serverAddress" type="java.net.InetSocketAddress"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.NMProxy -->
  <!-- start class org.apache.hadoop.yarn.client.RMProxy -->
  <class name="RMProxy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RMProxy"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createRetryPolicy" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="retryTime" type="long"/>
      <param name="retryInterval" type="long"/>
      <param name="isHAEnabled" type="boolean"/>
      <doc>
      <![CDATA[Fetch retry policy from Configuration and create the
 retry policy with specified retryTime and retry interval.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.RMProxy -->
  <!-- start class org.apache.hadoop.yarn.client.ServerProxy -->
  <class name="ServerProxy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerProxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createRetryPolicy" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="maxWaitTimeStr" type="java.lang.String"/>
      <param name="defMaxWaitTime" type="long"/>
      <param name="connectRetryIntervalStr" type="java.lang.String"/>
      <param name="defRetryInterval" type="long"/>
    </method>
    <method name="createRetriableProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="user" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="rpc" type="org.apache.hadoop.yarn.ipc.YarnRPC"/>
      <param name="serverAddress" type="java.net.InetSocketAddress"/>
      <param name="retryPolicy" type="org.apache.hadoop.io.retry.RetryPolicy"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.ServerProxy -->
</package>
<package name="org.apache.hadoop.yarn.client.api">
  <!-- start class org.apache.hadoop.yarn.client.api.TimelineClient -->
  <class name="TimelineClient" extends="org.apache.hadoop.service.CompositeService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <constructor name="TimelineClient" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createTimelineClient" return="org.apache.hadoop.yarn.client.api.TimelineClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an instance of the timeline v.1.x client.
 The current UGI when the user initialize the client will be used to do the
 put and the delegation token operations. The current user may use
 {@link UserGroupInformation#doAs} another user to construct and initialize
 a timeline client if the following operations are supposed to be conducted
 by that user.

 @return the created timeline client instance]]>
      </doc>
    </method>
    <method name="putEntities" return="org.apache.hadoop.yarn.api.records.timeline.TimelinePutResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entities" type="org.apache.hadoop.yarn.api.records.timeline.TimelineEntity[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Send the information of a number of conceptual entities to the timeline
 server. It is a blocking API. The method will not return until it gets the
 response from the timeline server.
 </p>
 
 @param entities
          the collection of {@link TimelineEntity}
 @return the error information if the sent entities are not correctly stored
 @throws IOException if there are I/O errors
 @throws YarnException if entities are incomplete/invalid]]>
      </doc>
    </method>
    <method name="putEntities" return="org.apache.hadoop.yarn.api.records.timeline.TimelinePutResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <param name="groupId" type="org.apache.hadoop.yarn.api.records.timeline.TimelineEntityGroupId"/>
      <param name="entities" type="org.apache.hadoop.yarn.api.records.timeline.TimelineEntity[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Send the information of a number of conceptual entities to the timeline
 server. It is a blocking API. The method will not return until it gets the
 response from the timeline server.

 This API is only for timeline service v1.5
 </p>

 @param appAttemptId {@link ApplicationAttemptId}
 @param groupId {@link TimelineEntityGroupId}
 @param entities
          the collection of {@link TimelineEntity}
 @return the error information if the sent entities are not correctly stored
 @throws IOException if there are I/O errors
 @throws YarnException if entities are incomplete/invalid]]>
      </doc>
    </method>
    <method name="putDomain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="org.apache.hadoop.yarn.api.records.timeline.TimelineDomain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Send the information of a domain to the timeline server. It is a
 blocking API. The method will not return until it gets the response from
 the timeline server.
 </p>
 
 @param domain
          an {@link TimelineDomain} object
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <method name="putDomain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <param name="domain" type="org.apache.hadoop.yarn.api.records.timeline.TimelineDomain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Send the information of a domain to the timeline server. It is a
 blocking API. The method will not return until it gets the response from
 the timeline server.

 This API is only for timeline service v1.5
 </p>

 @param domain
          an {@link TimelineDomain} object
 @param appAttemptId {@link ApplicationAttemptId}
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Get a delegation token so as to be able to talk to the timeline server in a
 secure way.
 </p>
 
 @param renewer
          Address of the renewer who can renew these tokens when needed by
          securely talking to the timeline server
 @return a delegation token ({@link Token}) that can be used to talk to the
         timeline server
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timelineDT" type="org.apache.hadoop.security.token.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Renew a timeline delegation token.
 </p>
 
 @param timelineDT
          the delegation token to renew
 @return the new expiration time
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timelineDT" type="org.apache.hadoop.security.token.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Cancel a timeline delegation token.
 </p>
 
 @param timelineDT
          the delegation token to cancel
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A client library that can be used to post some information in terms of a
 number of conceptual entities. This client library needs to be used along
 with Timeline V.1.x server versions.
 Refer {@link TimelineV2Client} for ATS V2 interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.TimelineClient -->
</package>
<package name="org.apache.hadoop.yarn.client.api.impl">
</package>
<package name="org.apache.hadoop.yarn.event">
  <!-- start class org.apache.hadoop.yarn.event.AbstractEvent -->
  <class name="AbstractEvent" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.event.Event"/>
    <constructor name="AbstractEvent" type="TYPE"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractEvent" type="TYPE, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTimestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="TYPE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Parent class of all the events. All events extend this class.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.event.AbstractEvent -->
  <!-- start class org.apache.hadoop.yarn.event.AsyncDispatcher -->
  <class name="AsyncDispatcher" extends="org.apache.hadoop.service.AbstractService"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.event.Dispatcher"/>
    <constructor name="AsyncDispatcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AsyncDispatcher" type="java.util.concurrent.BlockingQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AsyncDispatcher" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set a name for this dispatcher thread.
 @param dispatcherName name of the dispatcher thread]]>
      </doc>
    </constructor>
    <method name="serviceInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="serviceStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="setDrainEventsOnStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serviceStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="dispatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="event" type="org.apache.hadoop.yarn.event.Event"/>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eventType" type="java.lang.Class"/>
      <param name="handler" type="org.apache.hadoop.yarn.event.EventHandler"/>
    </method>
    <method name="getEventHandler" return="org.apache.hadoop.yarn.event.EventHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEventThreadWaiting" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="isDrained" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="isStopped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <field name="eventDispatchers" type="java.util.Map"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Dispatches {@link Event}s in a separate thread. Currently only single thread
 does that. Potentially there could be multiple channels for each event type
 class and a thread pool can be used to dispatch the events.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.event.AsyncDispatcher -->
  <!-- start interface org.apache.hadoop.yarn.event.Dispatcher -->
  <interface name="Dispatcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEventHandler" return="org.apache.hadoop.yarn.event.EventHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eventType" type="java.lang.Class"/>
      <param name="handler" type="org.apache.hadoop.yarn.event.EventHandler"/>
    </method>
    <field name="DISPATCHER_EXIT_ON_ERROR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_DISPATCHER_EXIT_ON_ERROR" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Event Dispatcher interface. It dispatches events to registered 
 event handlers based on event types.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.event.Dispatcher -->
  <!-- start interface org.apache.hadoop.yarn.event.Event -->
  <interface name="Event"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getType" return="TYPE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTimestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface defining events api.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.event.Event -->
  <!-- start interface org.apache.hadoop.yarn.event.EventHandler -->
  <interface name="EventHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="T"/>
    </method>
    <doc>
    <![CDATA[Interface for handling events of type T

 @param <T> parameterized event of type T]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.event.EventHandler -->
</package>
<package name="org.apache.hadoop.yarn.factories">
</package>
<package name="org.apache.hadoop.yarn.factory.providers">
</package>
<package name="org.apache.hadoop.yarn.logaggregation">
  <!-- start class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat -->
  <class name="AggregatedLogFormat" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AggregatedLogFormat"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat -->
  <!-- start class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogKey -->
  <class name="AggregatedLogFormat.LogKey" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="AggregatedLogFormat.LogKey"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AggregatedLogFormat.LogKey" type="org.apache.hadoop.yarn.api.records.ContainerId"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AggregatedLogFormat.LogKey" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogKey -->
  <!-- start class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogReader -->
  <class name="AggregatedLogFormat.LogReader" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AggregatedLogFormat.LogReader" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="getApplicationOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the owner of the application.

 @return the application owner.
 @throws IOException if we can not get the application owner.]]>
      </doc>
    </method>
    <method name="getApplicationAcls" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns ACLs for the application. An empty map is returned if no ACLs are
 found.

 @return a map of the Application ACLs.
 @throws IOException if we can not get the application acls.]]>
      </doc>
    </method>
    <method name="next" return="java.io.DataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogKey"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key and return the value-stream.
 
 @param key the log key
 @return the valueStream if there are more keys or null otherwise
 @throws IOException if we can not get the dataInputStream
 for the next key]]>
      </doc>
    </method>
    <method name="readAcontainerLogs"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="writer" type="java.io.Writer"/>
      <param name="logUploadedTime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes all logs for a single container to the provided writer.
 @param valueStream the valueStream
 @param writer the log writer
 @param logUploadedTime the time stamp
 @throws IOException if we can not read the container logs.]]>
      </doc>
    </method>
    <method name="readAcontainerLogs"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="writer" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes all logs for a single container to the provided writer.
 @param valueStream the value stream
 @param writer the log writer
 @throws IOException if we can not read the container logs.]]>
      </doc>
    </method>
    <method name="readAContainerLogsForALogType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <param name="logUploadedTime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 all types for a single container.
 
 @param valueStream the value stream
 @param out the print stream
 @param logUploadedTime the time stamp
 @throws IOException if we can not read the container log by specifying
 the container log type.]]>
      </doc>
    </method>
    <method name="readAContainerLogsForALogType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <param name="logUploadedTime" type="long"/>
      <param name="bytes" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 all types for a single container for the specific bytes.

 @param valueStream the value stream
 @param out the output print stream
 @param logUploadedTime the log upload time stamp
 @param bytes the output size of the log
 @throws IOException if we can not read the container log]]>
      </doc>
    </method>
    <method name="readAContainerLogsForALogType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 all types for a single container.
 
 @param valueStream the value stream
 @param out the output print stream
 @throws IOException if we can not read the container log]]>
      </doc>
    </method>
    <method name="readContainerLogsForALogType" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <param name="logUploadedTime" type="long"/>
      <param name="logType" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 the specific types for a single container.
 @param valueStream the value stream
 @param out the output print stream
 @param logUploadedTime the log uploaded time stamp
 @param logType the given log type
 @throws IOException if we can not read the container logs]]>
      </doc>
    </method>
    <method name="readContainerLogsForALogType" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <param name="logUploadedTime" type="long"/>
      <param name="logType" type="java.util.List"/>
      <param name="bytes" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 the specific types for a single container.
 @param valueStream the value stream
 @param out the output print stream
 @param logUploadedTime the log uploaded time stamp
 @param logType the given log type
 @throws IOException if we can not read the container logs]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogReader -->
</package>
<package name="org.apache.hadoop.yarn.logaggregation.filecontroller">
</package>
<package name="org.apache.hadoop.yarn.logaggregation.filecontroller.ifile">
</package>
<package name="org.apache.hadoop.yarn.logaggregation.filecontroller.tfile">
</package>
<package name="org.apache.hadoop.yarn.nodelabels">
</package>
<package name="org.apache.hadoop.yarn.nodelabels.event">
</package>
<package name="org.apache.hadoop.yarn.security">
  <!-- start class org.apache.hadoop.yarn.security.AccessRequest -->
  <class name="AccessRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessRequest" type="org.apache.hadoop.yarn.security.PrivilegedEntity, org.apache.hadoop.security.UserGroupInformation, org.apache.hadoop.yarn.security.AccessType, java.lang.String, java.lang.String, java.lang.String, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAccessType" return="org.apache.hadoop.yarn.security.AccessType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAppId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAppName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntity" return="org.apache.hadoop.yarn.security.PrivilegedEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getForwardedAddresses" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRemoteAddress" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This request object contains all the context information to determine whether
 a user has permission to access the target entity.
 user       : the user who's currently accessing
 accessType : the access type against the entity.
 entity     : the target object user is accessing.
 appId      : the associated app Id for current access. This could be null
              if no app is associated.
 appName    : the associated app name for current access. This could be null if
              no app is associated.
 remoteAddress : The caller's remote ip address.
 forwardedAddresses : In case this is an http request, this contains the
                    originating IP address of a client connecting to a web
                    server through an HTTP proxy or load balancer. This
                    parameter is null, if it's a RPC request.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.AccessRequest -->
  <!-- start class org.apache.hadoop.yarn.security.AMRMTokenIdentifier -->
  <class name="AMRMTokenIdentifier" extends="org.apache.hadoop.security.token.TokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AMRMTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AMRMTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeyId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProto" return="org.apache.hadoop.yarn.proto.YarnSecurityTokenProtos.AMRMTokenIdentifierProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND_NAME" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[AMRMTokenIdentifier is the TokenIdentifier to be used by
 ApplicationMasters to authenticate to the ResourceManager.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.AMRMTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.AMRMTokenSelector -->
  <class name="AMRMTokenSelector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.token.TokenSelector"/>
    <constructor name="AMRMTokenSelector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="selectToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <param name="tokens" type="java.util.Collection"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.AMRMTokenSelector -->
  <!-- start class org.apache.hadoop.yarn.security.ContainerManagerSecurityInfo -->
  <class name="ContainerManagerSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ContainerManagerSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.ContainerManagerSecurityInfo -->
  <!-- start class org.apache.hadoop.yarn.security.ContainerTokenIdentifier -->
  <class name="ContainerTokenIdentifier" extends="org.apache.hadoop.security.token.TokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext"
      static="false" final="false" visibility="public"
      deprecated="Use one of the other constructors instead.">
      <doc>
      <![CDATA[Creates a instance.

 @param appSubmitter appSubmitter
 @param containerID container ID
 @param creationTime creation time
 @param expiryTimeStamp expiry timestamp
 @param hostName hostname
 @param logAggregationContext log aggregation context
 @param masterKeyId master key ID
 @param priority priority
 @param r resource needed by the container
 @param rmIdentifier ResourceManager identifier
 @deprecated Use one of the other constructors instead.]]>
      </doc>
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext, java.lang.String, org.apache.hadoop.yarn.server.api.ContainerType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, int, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext, java.lang.String, org.apache.hadoop.yarn.server.api.ContainerType, org.apache.hadoop.yarn.api.records.ExecutionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ContainerTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor needed by RPC layer/SecretManager.]]>
      </doc>
    </constructor>
    <method name="getContainerID" return="org.apache.hadoop.yarn.api.records.ContainerId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getApplicationSubmitter" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNmHostAddress" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResource" return="org.apache.hadoop.yarn.api.records.Resource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExpiryTimeStamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMasterKeyId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPriority" return="org.apache.hadoop.yarn.api.records.Priority"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCreationTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRMIdentifier" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the RMIdentifier of RM in which containers are allocated.
 @return RMIdentifier]]>
      </doc>
    </method>
    <method name="getContainerType" return="org.apache.hadoop.yarn.server.api.ContainerType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the ContainerType of container to allocate.
 @return ContainerType]]>
      </doc>
    </method>
    <method name="getExecutionType" return="org.apache.hadoop.yarn.api.records.ExecutionType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the ExecutionType of container to allocate
 @return ExecutionType]]>
      </doc>
    </method>
    <method name="getProto" return="org.apache.hadoop.yarn.proto.YarnSecurityTokenProtos.ContainerTokenIdentifierProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLogAggregationContext" return="org.apache.hadoop.yarn.api.records.LogAggregationContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Container version
 @return container version]]>
      </doc>
    </method>
    <method name="getNodeLabelExpression" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the node-label-expression in the original ResourceRequest]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[TokenIdentifier for a container. Encodes {@link ContainerId},
 {@link Resource} needed by the container and the target NMs host-address.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.ContainerTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.ContainerTokenSelector -->
  <class name="ContainerTokenSelector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.token.TokenSelector"/>
    <constructor name="ContainerTokenSelector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="selectToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <param name="tokens" type="java.util.Collection"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.ContainerTokenSelector -->
  <!-- start class org.apache.hadoop.yarn.security.NMTokenIdentifier -->
  <class name="NMTokenIdentifier" extends="org.apache.hadoop.security.token.TokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId, org.apache.hadoop.yarn.api.records.NodeId, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NMTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor needed by RPC/Secret manager]]>
      </doc>
    </constructor>
    <method name="getApplicationAttemptId" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNodeId" return="org.apache.hadoop.yarn.api.records.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getApplicationSubmitter" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeyId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProto" return="org.apache.hadoop.yarn.proto.YarnSecurityTokenProtos.NMTokenIdentifierProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.NMTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.SchedulerSecurityInfo -->
  <class name="SchedulerSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SchedulerSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.SchedulerSecurityInfo -->
</package>
<package name="org.apache.hadoop.yarn.security.admin">
  <!-- start class org.apache.hadoop.yarn.security.admin.AdminSecurityInfo -->
  <class name="AdminSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AdminSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.admin.AdminSecurityInfo -->
</package>
<package name="org.apache.hadoop.yarn.security.client">
  <!-- start class org.apache.hadoop.yarn.security.client.BaseClientToAMTokenSecretManager -->
  <class name="BaseClientToAMTokenSecretManager" extends="org.apache.hadoop.security.token.SecretManager"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BaseClientToAMTokenSecretManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A base {@link SecretManager} for AMs to extend and validate Client-RM tokens
 issued to clients by the RM using the underlying master-key shared by RM to
 the AMs on their launch. All the methods are called by either Hadoop RPC or
 YARN, so this class is strictly for the purpose of inherit/extend and
 register with Hadoop RPC.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.BaseClientToAMTokenSecretManager -->
  <!-- start class org.apache.hadoop.yarn.security.client.ClientRMSecurityInfo -->
  <class name="ClientRMSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientRMSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.ClientRMSecurityInfo -->
  <!-- start class org.apache.hadoop.yarn.security.client.ClientTimelineSecurityInfo -->
  <class name="ClientTimelineSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientTimelineSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.ClientTimelineSecurityInfo -->
  <!-- start class org.apache.hadoop.yarn.security.client.ClientToAMTokenIdentifier -->
  <class name="ClientToAMTokenIdentifier" extends="org.apache.hadoop.security.token.TokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientToAMTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ClientToAMTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getApplicationAttemptID" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClientName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProto" return="org.apache.hadoop.yarn.proto.YarnSecurityTokenProtos.ClientToAMTokenIdentifierProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND_NAME" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.ClientToAMTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.client.ClientToAMTokenSecretManager -->
  <class name="ClientToAMTokenSecretManager" extends="org.apache.hadoop.yarn.security.client.BaseClientToAMTokenSecretManager"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientToAMTokenSecretManager" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId, byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="retrievePassword" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="identifier" type="org.apache.hadoop.yarn.security.client.ClientToAMTokenIdentifier"/>
      <exception name="SecretManager.InvalidToken" type="org.apache.hadoop.security.token.SecretManager.InvalidToken"/>
    </method>
    <method name="getMasterKey" return="javax.crypto.SecretKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptID" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
    </method>
    <method name="setMasterKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
    </method>
    <doc>
    <![CDATA[A simple {@link SecretManager} for AMs to validate Client-RM tokens issued to
 clients by the RM using the underlying master-key shared by RM to the AMs on
 their launch. All the methods are called by either Hadoop RPC or YARN, so
 this class is strictly for the purpose of inherit/extend and register with
 Hadoop RPC.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.ClientToAMTokenSecretManager -->
  <!-- start class org.apache.hadoop.yarn.security.client.RMDelegationTokenIdentifier -->
  <class name="RMDelegationTokenIdentifier" extends="org.apache.hadoop.yarn.security.client.YARNDelegationTokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RMDelegationTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RMDelegationTokenIdentifier" type="org.apache.hadoop.io.Text, org.apache.hadoop.io.Text, org.apache.hadoop.io.Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new delegation token identifier
 @param owner the effective username of the token owner
 @param renewer the username of the renewer
 @param realUser the real username of the token owner]]>
      </doc>
    </constructor>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND_NAME" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Delegation Token Identifier that identifies the delegation tokens from the 
 Resource Manager.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.RMDelegationTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.client.RMDelegationTokenSelector -->
  <class name="RMDelegationTokenSelector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.token.TokenSelector"/>
    <constructor name="RMDelegationTokenSelector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="selectToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <param name="tokens" type="java.util.Collection"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.RMDelegationTokenSelector -->
  <!-- start class org.apache.hadoop.yarn.security.client.TimelineDelegationTokenIdentifier -->
  <class name="TimelineDelegationTokenIdentifier" extends="org.apache.hadoop.yarn.security.client.YARNDelegationTokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimelineDelegationTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimelineDelegationTokenIdentifier" type="org.apache.hadoop.io.Text, org.apache.hadoop.io.Text, org.apache.hadoop.io.Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new timeline delegation token identifier

 @param owner the effective username of the token owner
 @param renewer the username of the renewer
 @param realUser the real username of the token owner]]>
      </doc>
    </constructor>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND_NAME" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.TimelineDelegationTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.client.TimelineDelegationTokenSelector -->
  <class name="TimelineDelegationTokenSelector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.token.TokenSelector"/>
    <constructor name="TimelineDelegationTokenSelector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="selectToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <param name="tokens" type="java.util.Collection"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.TimelineDelegationTokenSelector -->
</package>
<package name="org.apache.hadoop.yarn.server.api">
</package>
<package name="org.apache.hadoop.yarn.server.api.impl.pb.client">
</package>
<package name="org.apache.hadoop.yarn.server.api.impl.pb.service">
</package>
<package name="org.apache.hadoop.yarn.sharedcache">
  <!-- start interface org.apache.hadoop.yarn.sharedcache.SharedCacheChecksum -->
  <interface name="SharedCacheChecksum"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="computeChecksum" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Calculate the checksum of the passed input stream.

 @param in <code>InputStream</code> to be checksumed
 @return the message digest of the input stream
 @throws IOException]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.sharedcache.SharedCacheChecksum -->
  <!-- start class org.apache.hadoop.yarn.sharedcache.SharedCacheChecksumFactory -->
  <class name="SharedCacheChecksumFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SharedCacheChecksumFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getChecksum" return="org.apache.hadoop.yarn.sharedcache.SharedCacheChecksum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get a new <code>SharedCacheChecksum</code> object based on the configurable
 algorithm implementation
 (see <code>yarn.sharedcache.checksum.algo.impl</code>)

 @return <code>SharedCacheChecksum</code> object]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.sharedcache.SharedCacheChecksumFactory -->
</package>
<package name="org.apache.hadoop.yarn.state">
  <!-- start class org.apache.hadoop.yarn.state.InvalidStateTransitionException -->
  <class name="InvalidStateTransitionException" extends="org.apache.hadoop.yarn.state.InvalidStateTransitonException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidStateTransitionException" type="java.lang.Enum, java.lang.Enum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[The exception that happens when you call invalid state transition.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.state.InvalidStateTransitionException -->
  <!-- start class org.apache.hadoop.yarn.state.InvalidStateTransitonException -->
  <class name="InvalidStateTransitonException" extends="org.apache.hadoop.yarn.exceptions.YarnRuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Use {@link InvalidStateTransitionException} instead.">
    <constructor name="InvalidStateTransitonException" type="java.lang.Enum, java.lang.Enum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCurrentState" return="java.lang.Enum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEvent" return="java.lang.Enum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated Use {@link InvalidStateTransitionException} instead.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.state.InvalidStateTransitonException -->
  <!-- start interface org.apache.hadoop.yarn.state.MultipleArcTransition -->
  <interface name="MultipleArcTransition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="transition" return="STATE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
      <param name="event" type="EVENT"/>
      <doc>
      <![CDATA[Transition hook.
 @return the postState. Post state must be one of the 
                      valid post states registered in StateMachine.
 @param operand the entity attached to the FSM, whose internal 
                state may change.
 @param event causal event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Hook for Transition. 
 Post state is decided by Transition hook. Post state must be one of the 
 valid post states registered in StateMachine.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.state.MultipleArcTransition -->
  <!-- start interface org.apache.hadoop.yarn.state.SingleArcTransition -->
  <interface name="SingleArcTransition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="transition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
      <param name="event" type="EVENT"/>
      <doc>
      <![CDATA[Transition hook.
 
 @param operand the entity attached to the FSM, whose internal 
                state may change.
 @param event causal event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Hook for Transition. This lead to state machine to move to 
 the post state as registered in the state machine.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.state.SingleArcTransition -->
  <!-- start interface org.apache.hadoop.yarn.state.StateMachine -->
  <interface name="StateMachine"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getCurrentState" return="STATE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doTransition" return="STATE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eventType" type="EVENTTYPE"/>
      <param name="event" type="EVENT"/>
      <exception name="InvalidStateTransitionException" type="org.apache.hadoop.yarn.state.InvalidStateTransitionException"/>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.state.StateMachine -->
  <!-- start class org.apache.hadoop.yarn.state.StateMachineFactory -->
  <class name="StateMachineFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="StateMachineFactory" type="STATE"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor

 This is the only constructor in the API.]]>
      </doc>
    </constructor>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postState" type="STATE"/>
      <param name="eventType" type="EVENTTYPE"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition.  This overload
          has no hook object.

         Note that the returned StateMachineFactory is a distinct
         object.

         This method is part of the API.

 @param preState pre-transition state
 @param postState post-transition state
 @param eventType stimulus for the transition]]>
      </doc>
    </method>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postState" type="STATE"/>
      <param name="eventTypes" type="java.util.Set"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition.  This overload
          has no hook object.


         Note that the returned StateMachineFactory is a distinct
         object.

         This method is part of the API.

 @param preState pre-transition state
 @param postState post-transition state
 @param eventTypes List of stimuli for the transitions]]>
      </doc>
    </method>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postState" type="STATE"/>
      <param name="eventTypes" type="java.util.Set"/>
      <param name="hook" type="org.apache.hadoop.yarn.state.SingleArcTransition"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition

         Note that the returned StateMachineFactory is a distinct
         object.

         This method is part of the API.

 @param preState pre-transition state
 @param postState post-transition state
 @param eventTypes List of stimuli for the transitions
 @param hook transition hook]]>
      </doc>
    </method>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postState" type="STATE"/>
      <param name="eventType" type="EVENTTYPE"/>
      <param name="hook" type="org.apache.hadoop.yarn.state.SingleArcTransition"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition

         Note that the returned StateMachineFactory is a distinct object.

         This method is part of the API.

 @param preState pre-transition state
 @param postState post-transition state
 @param eventType stimulus for the transition
 @param hook transition hook]]>
      </doc>
    </method>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postStates" type="java.util.Set"/>
      <param name="eventType" type="EVENTTYPE"/>
      <param name="hook" type="org.apache.hadoop.yarn.state.MultipleArcTransition"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition

         Note that the returned StateMachineFactory is a distinct object.

         This method is part of the API.

 @param preState pre-transition state
 @param postStates valid post-transition states
 @param eventType stimulus for the transition
 @param hook transition hook]]>
      </doc>
    </method>
    <method name="installTopology" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return a StateMachineFactory just like {@code this}, except that if
         you won't need any synchronization to build a state machine

         Note that the returned StateMachineFactory is a distinct object.

         This method is part of the API.

         The only way you could distinguish the returned
         StateMachineFactory from {@code this} would be by
         measuring the performance of the derived 
         {@code StateMachine} you can get from it.

 Calling this is optional.  It doesn't change the semantics of the factory,
   if you call it then when you use the factory there is no synchronization.]]>
      </doc>
    </method>
    <method name="make" return="org.apache.hadoop.yarn.state.StateMachine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
      <param name="initialState" type="STATE"/>
      <param name="listener" type="org.apache.hadoop.yarn.state.StateTransitionListener"/>
      <doc>
      <![CDATA[A StateMachine that accepts a transition listener.
 @param operand the object upon which the returned
                {@link StateMachine} will operate.
 @param initialState the state in which the returned
                {@link StateMachine} will start.
 @param listener An implementation of a {@link StateTransitionListener}.
 @return A (@link StateMachine}.]]>
      </doc>
    </method>
    <method name="make" return="org.apache.hadoop.yarn.state.StateMachine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
      <param name="initialState" type="STATE"/>
    </method>
    <method name="make" return="org.apache.hadoop.yarn.state.StateMachine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
    </method>
    <method name="generateStateGraph" return="org.apache.hadoop.yarn.state.Graph"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Generate a graph represents the state graph of this StateMachine
 @param name graph name
 @return Graph object generated]]>
      </doc>
    </method>
    <doc>
    <![CDATA[State machine topology.
 This object is semantically immutable.  If you have a
 StateMachineFactory there's no operation in the API that changes
 its semantic properties.

 @param <OPERAND> The object type on which this state machine operates.
 @param <STATE> The state of the entity.
 @param <EVENTTYPE> The external eventType to be handled.
 @param <EVENT> The event object.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.state.StateMachineFactory -->
  <!-- start interface org.apache.hadoop.yarn.state.StateTransitionListener -->
  <interface name="StateTransitionListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="preTransition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="OPERAND"/>
      <param name="beforeState" type="STATE"/>
      <param name="eventToBeProcessed" type="EVENT"/>
      <doc>
      <![CDATA[Pre Transition Hook. This will be called before transition.
 @param op Operand.
 @param beforeState State before transition.
 @param eventToBeProcessed Incoming Event.]]>
      </doc>
    </method>
    <method name="postTransition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="OPERAND"/>
      <param name="beforeState" type="STATE"/>
      <param name="afterState" type="STATE"/>
      <param name="processedEvent" type="EVENT"/>
      <doc>
      <![CDATA[Post Transition Hook. This will be called after the transition.
 @param op Operand.
 @param beforeState State before transition.
 @param afterState State after transition.
 @param processedEvent Processed Event.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A State Transition Listener.
 It exposes a pre and post transition hook called before and
 after the transition.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.state.StateTransitionListener -->
</package>
<package name="org.apache.hadoop.yarn.util">
  <!-- start class org.apache.hadoop.yarn.util.AbstractLivelinessMonitor -->
  <class name="AbstractLivelinessMonitor" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractLivelinessMonitor" type="java.lang.String, org.apache.hadoop.yarn.util.Clock"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractLivelinessMonitor" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="serviceStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="serviceStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="expire"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
    </method>
    <method name="setExpireInterval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="expireInterval" type="int"/>
    </method>
    <method name="getExpireInterval" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="o" type="O"/>
    </method>
    <method name="setMonitorInterval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="monitorInterval" type="long"/>
    </method>
    <method name="receivedPing"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
      <param name="expireTime" type="long"/>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
    </method>
    <method name="resetTimer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setResetTimeOnStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="resetTimeOnStart" type="boolean"/>
    </method>
    <field name="DEFAULT_EXPIRE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A simple liveliness monitor with which clients can register, trust the
 component to monitor liveliness, get a call-back on expiry and then finally
 unregister.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.AbstractLivelinessMonitor -->
  <!-- start class org.apache.hadoop.yarn.util.ApplicationClassLoader -->
  <class name="ApplicationClassLoader" extends="org.apache.hadoop.util.ApplicationClassLoader"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ApplicationClassLoader" type="java.net.URL[], java.lang.ClassLoader, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ApplicationClassLoader" type="java.lang.String, java.lang.ClassLoader, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="MalformedURLException" type="java.net.MalformedURLException"/>
    </constructor>
    <doc>
    <![CDATA[This type has been deprecated in favor of
 {@link org.apache.hadoop.util.ApplicationClassLoader}. All new uses of
 ApplicationClassLoader should use that type instead.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.ApplicationClassLoader -->
  <!-- start interface org.apache.hadoop.yarn.util.Clock -->
  <interface name="Clock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simple clock interface that gives you time.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.util.Clock -->
  <!-- start class org.apache.hadoop.yarn.util.ConverterUtils -->
  <class name="ConverterUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConverterUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPathFromYarnURL" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="org.apache.hadoop.yarn.api.records.URL"/>
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
      <doc>
      <![CDATA[return a hadoop path from a given url
 This method is deprecated, use {@link URL#toPath()} instead.
 
 @param url
          url to convert
 @return path from {@link URL}
 @throws URISyntaxException]]>
      </doc>
    </method>
    <method name="getYarnUrlFromPath" return="org.apache.hadoop.yarn.api.records.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getYarnUrlFromURI" return="org.apache.hadoop.yarn.api.records.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
    </method>
    <method name="toApplicationId" return="org.apache.hadoop.yarn.api.records.ApplicationId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recordFactory" type="org.apache.hadoop.yarn.factories.RecordFactory"/>
      <param name="applicationIdStr" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
    </method>
    <method name="toNodeId" return="org.apache.hadoop.yarn.api.records.NodeId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeIdStr" type="java.lang.String"/>
    </method>
    <method name="toContainerId" return="org.apache.hadoop.yarn.api.records.ContainerId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerIdStr" type="java.lang.String"/>
    </method>
    <method name="toApplicationAttemptId" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptIdStr" type="java.lang.String"/>
    </method>
    <method name="toApplicationId" return="org.apache.hadoop.yarn.api.records.ApplicationId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appIdStr" type="java.lang.String"/>
    </method>
    <method name="convertFromYarn" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protoToken" type="org.apache.hadoop.yarn.api.records.Token"/>
      <param name="serviceAddr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Convert a protobuf token into a rpc token and set its service. Supposed
 to be used for tokens other than RMDelegationToken. For
 RMDelegationToken, use
 {@link #convertFromYarn(org.apache.hadoop.yarn.api.records.Token,
 org.apache.hadoop.io.Text)} instead.

 @param protoToken the yarn token
 @param serviceAddr the connect address for the service
 @return rpc token]]>
      </doc>
    </method>
    <method name="convertFromYarn" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protoToken" type="org.apache.hadoop.yarn.api.records.Token"/>
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[Convert a protobuf token into a rpc token and set its service.

 @param protoToken the yarn token
 @param service the service for the token]]>
      </doc>
    </method>
    <field name="APPLICATION_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONTAINER_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="APPLICATION_ATTEMPT_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class contains a set of utilities which help converting data structures
 from/to 'serializableFormat' to/from hadoop/nativejava data structures.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.ConverterUtils -->
  <!-- start class org.apache.hadoop.yarn.util.MonotonicClock -->
  <class name="MonotonicClock" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.util.Clock"/>
    <constructor name="MonotonicClock"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get current time from some arbitrary time base in the past, counting in
 milliseconds, and not affected by settimeofday or similar system clock
 changes.
 @return a monotonic clock that counts in milliseconds.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A monotonic clock from some arbitrary time base in the past, counting in
 milliseconds, and not affected by settimeofday or similar system clock
 changes.
 This is appropriate to use when computing how much longer to wait for an
 interval to expire.
 This function can return a negative value and it must be handled correctly
 by callers. See the documentation of System#nanoTime for caveats.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.MonotonicClock -->
  <!-- start class org.apache.hadoop.yarn.util.ResourceCalculatorProcessTree -->
  <class name="ResourceCalculatorProcessTree" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ResourceCalculatorProcessTree" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create process-tree instance with specified root process.

 Subclass must override this.
 @param root process-tree root-process]]>
      </doc>
    </constructor>
    <method name="updateProcessTree"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Update the process-tree with latest state.

 Each call to this function should increment the age of the running
 processes that already exist in the process tree. Age is used other API's
 of the interface.]]>
      </doc>
    </method>
    <method name="getProcessTreeDump" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a dump of the process-tree.

 @return a string concatenating the dump of information of all the processes
         in the process-tree]]>
      </doc>
    </method>
    <method name="getVirtualMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the virtual memory used by all the processes in the
 process-tree.

 @return virtual memory used by the process-tree in bytes,
 {@link #UNAVAILABLE} if it cannot be calculated.]]>
      </doc>
    </method>
    <method name="getCumulativeVmem" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the virtual memory used by all the processes in the
 process-tree.

 @return virtual memory used by the process-tree in bytes,
 {@link #UNAVAILABLE} if it cannot be calculated.]]>
      </doc>
    </method>
    <method name="getRssMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the resident set size (rss) memory used by all the processes
 in the process-tree.

 @return rss memory used by the process-tree in bytes,
 {@link #UNAVAILABLE} if it cannot be calculated.]]>
      </doc>
    </method>
    <method name="getCumulativeRssmem" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the resident set size (rss) memory used by all the processes
 in the process-tree.

 @return rss memory used by the process-tree in bytes,
 {@link #UNAVAILABLE} if it cannot be calculated.]]>
      </doc>
    </method>
    <method name="getVirtualMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="olderThanAge" type="int"/>
      <doc>
      <![CDATA[Get the virtual memory used by all the processes in the
 process-tree that are older than the passed in age.

 @param olderThanAge processes above this age are included in the
                     memory addition
 @return virtual memory used by the process-tree in bytes for
 processes older than the specified age, {@link #UNAVAILABLE} if it
 cannot be calculated.]]>
      </doc>
    </method>
    <method name="getCumulativeVmem" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="olderThanAge" type="int"/>
      <doc>
      <![CDATA[Get the virtual memory used by all the processes in the
 process-tree that are older than the passed in age.

 @param olderThanAge processes above this age are included in the
                     memory addition
 @return virtual memory used by the process-tree in bytes for
 processes older than the specified age, {@link #UNAVAILABLE} if it
 cannot be calculated.]]>
      </doc>
    </method>
    <method name="getRssMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="olderThanAge" type="int"/>
      <doc>
      <![CDATA[Get the resident set size (rss) memory used by all the processes
 in the process-tree that are older than the passed in age.

 @param olderThanAge processes above this age are included in the
                     memory addition
 @return rss memory used by the process-tree in bytes for
 processes older than specified age, {@link #UNAVAILABLE} if it cannot be
 calculated.]]>
      </doc>
    </method>
    <method name="getCumulativeRssmem" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="olderThanAge" type="int"/>
      <doc>
      <![CDATA[Get the resident set size (rss) memory used by all the processes
 in the process-tree that are older than the passed in age.

 @param olderThanAge processes above this age are included in the
                     memory addition
 @return rss memory used by the process-tree in bytes for
 processes older than specified age, {@link #UNAVAILABLE} if it cannot be
 calculated.]]>
      </doc>
    </method>
    <method name="getCumulativeCpuTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the CPU time in millisecond used by all the processes in the
 process-tree since the process-tree was created

 @return cumulative CPU time in millisecond since the process-tree
 created, {@link #UNAVAILABLE} if it cannot be calculated.]]>
      </doc>
    </method>
    <method name="getCpuUsagePercent" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the CPU usage by all the processes in the process-tree based on
 average between samples as a ratio of overall CPU cycles similar to top.
 Thus, if 2 out of 4 cores are used this should return 200.0.
 Note: UNAVAILABLE will be returned in case when CPU usage is not
 available. It is NOT advised to return any other error code.

 @return percentage CPU usage since the process-tree was created,
 {@link #UNAVAILABLE} if CPU usage cannot be calculated or not available.]]>
      </doc>
    </method>
    <method name="checkPidPgrpidForMatch" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Verify that the tree process id is same as its process group id.
 @return true if the process id matches else return false.]]>
      </doc>
    </method>
    <method name="getResourceCalculatorProcessTree" return="org.apache.hadoop.yarn.util.ResourceCalculatorProcessTree"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pid" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create the ResourceCalculatorProcessTree rooted to specified process 
 from the class name and configure it. If class name is null, this method
 will try and return a process tree plugin available for this system.

 @param pid process pid of the root of the process tree
 @param clazz class-name
 @param conf configure the plugin with this.

 @return ResourceCalculatorProcessTree or null if ResourceCalculatorPluginTree
         is not available for this system.]]>
      </doc>
    </method>
    <field name="UNAVAILABLE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Interface class to obtain process resource usage
 NOTE: This class should not be used by external users, but only by external
 developers to extend and include their own process-tree implementation, 
 especially for platforms other than Linux and Windows.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.ResourceCalculatorProcessTree -->
  <!-- start class org.apache.hadoop.yarn.util.SystemClock -->
  <class name="SystemClock" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.util.Clock"/>
    <constructor name="SystemClock"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInstance" return="org.apache.hadoop.yarn.util.SystemClock"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementation of {@link Clock} that gives the current time from the system
 clock in milliseconds.
 
 NOTE: Do not use this to calculate a duration of expire or interval to sleep,
 because it will be broken by settimeofday. Please use {@link MonotonicClock}
 instead.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.SystemClock -->
  <!-- start class org.apache.hadoop.yarn.util.UTCClock -->
  <class name="UTCClock" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.util.Clock"/>
    <constructor name="UTCClock"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementation of {@link Clock} that gives the current UTC time in
 milliseconds.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.UTCClock -->
</package>
<package name="org.apache.hadoop.yarn.util.resource">
</package>
<package name="org.apache.hadoop.yarn.util.timeline">
  <!-- start class org.apache.hadoop.yarn.util.timeline.TimelineUtils -->
  <class name="TimelineUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimelineUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="dumpTimelineRecordtoJSON" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <exception name="JsonGenerationException" type="org.codehaus.jackson.JsonGenerationException"/>
      <exception name="JsonMappingException" type="org.codehaus.jackson.map.JsonMappingException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize a POJO object into a JSON string not in a pretty format
 
 @param o
          an object to serialize
 @return a JSON string
 @throws IOException
 @throws JsonMappingException
 @throws JsonGenerationException]]>
      </doc>
    </method>
    <method name="dumpTimelineRecordtoJSON" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <param name="pretty" type="boolean"/>
      <exception name="JsonGenerationException" type="org.codehaus.jackson.JsonGenerationException"/>
      <exception name="JsonMappingException" type="org.codehaus.jackson.map.JsonMappingException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize a POJO object into a JSON string
 
 @param o
          an object to serialize
 @param pretty
          whether in a pretty format or not
 @return a JSON string
 @throws IOException
 @throws JsonMappingException
 @throws JsonGenerationException]]>
      </doc>
    </method>
    <method name="timelineServiceEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Returns whether the timeline service is enabled via configuration.

 @param conf the configuration
 @return whether the timeline service is enabled.]]>
      </doc>
    </method>
    <method name="getTimelineServiceVersion" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Returns the timeline service version. It does not check whether the
 timeline service itself is enabled.

 @param conf the configuration
 @return the timeline service version as a float.]]>
      </doc>
    </method>
    <method name="timelineServiceV1_5Enabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Returns whether the timeline service v.1.5 is enabled via configuration.

 @param conf the configuration
 @return whether the timeline service v.1.5 is enabled. V.1.5 refers to a
 version equal to 1.5.]]>
      </doc>
    </method>
    <method name="createTimelineAbout" return="org.apache.hadoop.yarn.api.records.timeline.TimelineAbout"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="about" type="java.lang.String"/>
    </method>
    <method name="getTimelineTokenServiceAddress" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="buildTimelineTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="generateDefaultFlowName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
    </method>
    <method name="generateFlowNameTag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flowName" type="java.lang.String"/>
      <doc>
      <![CDATA[Generate flow name tag.

 @param flowName flow name that identifies a distinct flow application which
                 can be run repeatedly over time
 @return flow name tag.]]>
      </doc>
    </method>
    <method name="generateFlowVersionTag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flowVersion" type="java.lang.String"/>
      <doc>
      <![CDATA[Generate flow version tag.

 @param flowVersion flow version that keeps track of the changes made to the
                    flow
 @return flow version tag.]]>
      </doc>
    </method>
    <method name="generateFlowRunIdTag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flowRunId" type="long"/>
      <doc>
      <![CDATA[Generate flow run ID tag.

 @param flowRunId flow run ID that identifies one instance (or specific
                  execution) of that flow
 @return flow run id tag.]]>
      </doc>
    </method>
    <field name="FLOW_NAME_TAG_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOW_VERSION_TAG_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOW_RUN_ID_TAG_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_FLOW_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The helper class for the timeline module.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.timeline.TimelineUtils -->
</package>
<package name="org.apache.hadoop.yarn.webapp.util">
</package>

</api>
