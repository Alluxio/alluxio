<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Mon Apr 16 12:07:06 UTC 2018 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Apache Hadoop YARN Client 2.9.1"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet org.apache.hadoop.classification.tools.IncludePublicAnnotationsJDiffDoclet -docletpath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/target/hadoop-annotations.jar:/build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/target/jdiff.jar -verbose -classpath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/target/classes:/build/source/hadoop-common-project/hadoop-common/target/hadoop-common-2.9.1.jar:/maven/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar:/maven/xmlenc/xmlenc/0.52/xmlenc-0.52.jar:/maven/org/apache/httpcomponents/httpclient/4.5.2/httpclient-4.5.2.jar:/maven/org/apache/httpcomponents/httpcore/4.4.4/httpcore-4.4.4.jar:/maven/commons-codec/commons-codec/1.4/commons-codec-1.4.jar:/maven/commons-io/commons-io/2.4/commons-io-2.4.jar:/maven/commons-net/commons-net/3.1/commons-net-3.1.jar:/maven/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/maven/javax/servlet/servlet-api/2.5/servlet-api-2.5.jar:/maven/org/mortbay/jetty/jetty/6.1.26/jetty-6.1.26.jar:/maven/org/mortbay/jetty/jetty-util/6.1.26/jetty-util-6.1.26.jar:/maven/org/mortbay/jetty/jetty-sslengine/6.1.26/jetty-sslengine-6.1.26.jar:/maven/javax/servlet/jsp/jsp-api/2.1/jsp-api-2.1.jar:/maven/com/sun/jersey/jersey-core/1.9/jersey-core-1.9.jar:/maven/com/sun/jersey/jersey-json/1.9/jersey-json-1.9.jar:/maven/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/maven/com/sun/jersey/jersey-server/1.9/jersey-server-1.9.jar:/maven/asm/asm/3.2/asm-3.2.jar:/maven/net/java/dev/jets3t/jets3t/0.9.0/jets3t-0.9.0.jar:/maven/com/jamesmurty/utils/java-xmlbuilder/0.4/java-xmlbuilder-0.4.jar:/maven/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jar:/maven/commons-digester/commons-digester/1.8/commons-digester-1.8.jar:/maven/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jar:/maven/commons-beanutils/commons-beanutils-core/1.8.0/commons-beanutils-core-1.8.0.jar:/maven/org/apache/commons/commons-lang3/3.4/commons-lang3-3.4.jar:/maven/org/slf4j/slf4j-api/1.7.25/slf4j-api-1.7.25.jar:/maven/org/slf4j/slf4j-log4j12/1.7.25/slf4j-log4j12-1.7.25.jar:/maven/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/maven/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/maven/org/apache/avro/avro/1.7.7/avro-1.7.7.jar:/maven/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/maven/org/xerial/snappy/snappy-java/1.0.5/snappy-java-1.0.5.jar:/maven/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/maven/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar:/build/source/hadoop-common-project/hadoop-auth/target/hadoop-auth-2.9.1.jar:/maven/com/nimbusds/nimbus-jose-jwt/4.41.1/nimbus-jose-jwt-4.41.1.jar:/maven/com/github/stephenc/jcip/jcip-annotations/1.0-1/jcip-annotations-1.0-1.jar:/maven/net/minidev/json-smart/1.3.1/json-smart-1.3.1.jar:/maven/org/apache/directory/server/apacheds-kerberos-codec/2.0.0-M15/apacheds-kerberos-codec-2.0.0-M15.jar:/maven/org/apache/directory/server/apacheds-i18n/2.0.0-M15/apacheds-i18n-2.0.0-M15.jar:/maven/org/apache/directory/api/api-asn1-api/1.0.0-M20/api-asn1-api-1.0.0-M20.jar:/maven/org/apache/directory/api/api-util/1.0.0-M20/api-util-1.0.0-M20.jar:/maven/org/apache/curator/curator-framework/2.7.1/curator-framework-2.7.1.jar:/maven/com/jcraft/jsch/0.1.54/jsch-0.1.54.jar:/maven/org/apache/curator/curator-client/2.7.1/curator-client-2.7.1.jar:/maven/org/apache/curator/curator-recipes/2.7.1/curator-recipes-2.7.1.jar:/maven/com/google/code/findbugs/jsr305/3.0.0/jsr305-3.0.0.jar:/maven/org/apache/htrace/htrace-core4/4.1.0-incubating/htrace-core4-4.1.0-incubating.jar:/maven/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar:/maven/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jar:/maven/org/tukaani/xz/1.0/xz-1.0.jar:/maven/org/codehaus/woodstox/stax2-api/3.1.4/stax2-api-3.1.4.jar:/maven/com/fasterxml/woodstox/woodstox-core/5.0.3/woodstox-core-5.0.3.jar:/maven/com/google/guava/guava/11.0.2/guava-11.0.2.jar:/maven/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/maven/commons-lang/commons-lang/2.6/commons-lang-2.6.jar:/maven/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/maven/log4j/log4j/1.2.17/log4j-1.2.17.jar:/build/source/hadoop-common-project/hadoop-annotations/target/hadoop-annotations-2.9.1.jar:/usr/lib/jvm/java-7-openjdk-amd64/lib/tools.jar:/maven/io/netty/netty/3.6.2.Final/netty-3.6.2.Final.jar:/build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/target/hadoop-yarn-api-2.9.1.jar:/maven/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jar:/maven/javax/xml/stream/stax-api/1.0-2/stax-api-1.0-2.jar:/maven/javax/activation/activation/1.1/activation-1.1.jar:/build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/hadoop-yarn-common-2.9.1.jar:/maven/com/sun/jersey/jersey-client/1.9/jersey-client-1.9.jar:/maven/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jar:/maven/org/codehaus/jackson/jackson-xc/1.9.13/jackson-xc-1.9.13.jar:/maven/com/google/inject/extensions/guice-servlet/3.0/guice-servlet-3.0.jar:/maven/com/google/inject/guice/3.0/guice-3.0.jar:/maven/javax/inject/javax.inject/1/javax.inject-1.jar:/maven/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/maven/com/sun/jersey/contribs/jersey-guice/1.9/jersey-guice-1.9.jar:/maven/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar -sourcepath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java -apidir /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/target/site/jdiff/xml -apiname Apache Hadoop YARN Client 2.9.1 -->
<package name="org.apache.hadoop.yarn.client">
</package>
<package name="org.apache.hadoop.yarn.client.api">
  <!-- start class org.apache.hadoop.yarn.client.api.AHSClient -->
  <class name="AHSClient" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AHSClient" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createAHSClient" return="org.apache.hadoop.yarn.client.api.AHSClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of AHSClient.]]>
      </doc>
    </method>
    <method name="getApplicationReport" return="org.apache.hadoop.yarn.api.records.ApplicationReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a report of the given Application.
 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 <p>
 If the user does not have <code>VIEW_APP</code> access then the following
 fields in the report will be set to stubbed values:
 <ul>
   <li>host - set to "N/A"</li>
   <li>RPC port - set to -1</li>
   <li>client token - set to "N/A"</li>
   <li>diagnostics - set to "N/A"</li>
   <li>tracking URL - set to "N/A"</li>
   <li>original tracking URL - set to "N/A"</li>
   <li>resource usage report - all values are -1</li>
 </ul>
 
 @param appId
          {@link ApplicationId} of the application that needs a report
 @return application report
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of all Applications in the cluster.
 </p>
 
 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>
 
 @return a list of reports for all applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttemptReport" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given ApplicationAttempt.
 </p>
 
 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>
 
 @param applicationAttemptId
          {@link ApplicationAttemptId} of the application attempt that needs
          a report
 @return application attempt report
 @throws YarnException
 @throws ApplicationAttemptNotFoundException if application attempt
         not found
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttempts" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of all (ApplicationAttempts) of Application in the cluster.
 </p>
 
 @param applicationId
 @return a list of reports for all application attempts for specified
         application
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainerReport" return="org.apache.hadoop.yarn.api.records.ContainerReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given Container.
 </p>
 
 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>
 
 @param containerId
          {@link ContainerId} of the container that needs a report
 @return container report
 @throws YarnException
 @throws ContainerNotFoundException if container not found
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainers" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of all (Containers) of ApplicationAttempt in the cluster.
 </p>
 
 @param applicationAttemptId
 @return a list of reports of all containers for specified application
         attempt
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.AHSClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.AMRMClient -->
  <class name="AMRMClient" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AMRMClient" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createAMRMClient" return="org.apache.hadoop.yarn.client.api.AMRMClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of AMRMClient.
 For usage:
 <pre>
 {@code
 AMRMClient.<T>createAMRMClientContainerRequest()
 }</pre>
 @return the newly create AMRMClient instance.]]>
      </doc>
    </method>
    <method name="registerApplicationMaster" return="org.apache.hadoop.yarn.api.protocolrecords.RegisterApplicationMasterResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appHostName" type="java.lang.String"/>
      <param name="appHostPort" type="int"/>
      <param name="appTrackingUrl" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Register the application master. This must be called before any 
 other interaction
 @param appHostName Name of the host on which master is running
 @param appHostPort Port master is listening on
 @param appTrackingUrl URL at which the master info can be seen
 @return <code>RegisterApplicationMasterResponse</code>
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="allocate" return="org.apache.hadoop.yarn.api.protocolrecords.AllocateResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="progressIndicator" type="float"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request additional containers and receive new container allocations.
 Requests made via <code>addContainerRequest</code> are sent to the
 <code>ResourceManager</code>. New containers assigned to the master are
 retrieved. Status of completed containers and node health updates are also
 retrieved. This also doubles up as a heartbeat to the ResourceManager and
 must be made periodically. The call may not always return any new
 allocations of containers. App should not make concurrent allocate
 requests. May cause request loss.
 
 <p>
 Note : If the user has not removed container requests that have already
 been satisfied, then the re-register may end up sending the entire
 container requests to the RM (including matched requests). Which would mean
 the RM could end up giving it a lot of new allocated containers.
 </p>
 
 @param progressIndicator Indicates progress made by the master
 @return the response of the allocate request
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="unregisterApplicationMaster"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appStatus" type="org.apache.hadoop.yarn.api.records.FinalApplicationStatus"/>
      <param name="appMessage" type="java.lang.String"/>
      <param name="appTrackingUrl" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unregister the application master. This must be called in the end.
 @param appStatus Success/Failure status of the master
 @param appMessage Diagnostics message on failure
 @param appTrackingUrl New URL to get master info
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="addContainerRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="req" type="T"/>
      <doc>
      <![CDATA[Request containers for resources before calling <code>allocate</code>
 @param req Resource request]]>
      </doc>
    </method>
    <method name="removeContainerRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="req" type="T"/>
      <doc>
      <![CDATA[Remove previous container request. The previous container request may have 
 already been sent to the ResourceManager. So even after the remove request 
 the app must be prepared to receive an allocation for the previous request 
 even after the remove request
 @param req Resource request]]>
      </doc>
    </method>
    <method name="requestContainerResourceChange"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use
 {@link #requestContainerUpdate(Container, UpdateContainerRequest)}">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <param name="capability" type="org.apache.hadoop.yarn.api.records.Resource"/>
      <doc>
      <![CDATA[Request container resource change before calling <code>allocate</code>.
 Any previous pending resource change request of the same container will be
 removed.

 Application that calls this method is expected to maintain the
 <code>Container</code>s that are returned from previous successful
 allocations or resource changes. By passing in the existing container and a
 target resource capability to this method, the application requests the
 ResourceManager to change the existing resource allocation to the target
 resource allocation.

 @deprecated use
 {@link #requestContainerUpdate(Container, UpdateContainerRequest)}

 @param container The container returned from the last successful resource
                  allocation or resource change
 @param capability  The target resource capability of the container]]>
      </doc>
    </method>
    <method name="requestContainerUpdate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <param name="updateContainerRequest" type="org.apache.hadoop.yarn.api.records.UpdateContainerRequest"/>
      <doc>
      <![CDATA[Request a container update before calling <code>allocate</code>.
 Any previous pending update request of the same container will be
 removed.

 @param container The container returned from the last successful resource
                  allocation or update
 @param updateContainerRequest The <code>UpdateContainerRequest</code>.]]>
      </doc>
    </method>
    <method name="releaseAssignedContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <doc>
      <![CDATA[Release containers assigned by the Resource Manager. If the app cannot use
 the container or wants to give up the container then it can release them.
 The app needs to make new requests for the released resource capability if
 it still needs it. eg. it released non-local resources
 @param containerId]]>
      </doc>
    </method>
    <method name="getAvailableResources" return="org.apache.hadoop.yarn.api.records.Resource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the currently available resources in the cluster.
 A valid value is available after a call to allocate has been made
 @return Currently available resources]]>
      </doc>
    </method>
    <method name="getClusterNodeCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current number of nodes in the cluster.
 A valid values is available after a call to allocate has been made
 @return Current number of nodes in the cluster]]>
      </doc>
    </method>
    <method name="getMatchingRequests" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="org.apache.hadoop.yarn.api.records.Priority"/>
      <param name="resourceName" type="java.lang.String"/>
      <param name="capability" type="org.apache.hadoop.yarn.api.records.Resource"/>
      <doc>
      <![CDATA[Get outstanding <code>ContainerRequest</code>s matching the given 
 parameters. These ContainerRequests should have been added via
 <code>addContainerRequest</code> earlier in the lifecycle. For performance,
 the AMRMClient may return its internal collection directly without creating 
 a copy. Users should not perform mutable operations on the return value.
 Each collection in the list contains requests with identical 
 <code>Resource</code> size that fit in the given capability. In a 
 collection, requests will be returned in the same order as they were added.

 NOTE: This API only matches Container requests that were created by the
 client WITHOUT the allocationRequestId being set.

 @return Collection of request matching the parameters]]>
      </doc>
    </method>
    <method name="getMatchingRequests" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="org.apache.hadoop.yarn.api.records.Priority"/>
      <param name="resourceName" type="java.lang.String"/>
      <param name="executionType" type="org.apache.hadoop.yarn.api.records.ExecutionType"/>
      <param name="capability" type="org.apache.hadoop.yarn.api.records.Resource"/>
      <doc>
      <![CDATA[Get outstanding <code>ContainerRequest</code>s matching the given
 parameters. These ContainerRequests should have been added via
 <code>addContainerRequest</code> earlier in the lifecycle. For performance,
 the AMRMClient may return its internal collection directly without creating
 a copy. Users should not perform mutable operations on the return value.
 Each collection in the list contains requests with identical
 <code>Resource</code> size that fit in the given capability. In a
 collection, requests will be returned in the same order as they were added.
 specify an <code>ExecutionType</code>.

 NOTE: This API only matches Container requests that were created by the
 client WITHOUT the allocationRequestId being set.

 @param priority Priority
 @param resourceName Location
 @param executionType ExecutionType
 @param capability Capability
 @return Collection of request matching the parameters]]>
      </doc>
    </method>
    <method name="getMatchingRequests" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allocationRequestId" type="long"/>
      <doc>
      <![CDATA[Get outstanding <code>ContainerRequest</code>s matching the given
 allocationRequestId. These ContainerRequests should have been added via
 <code>addContainerRequest</code> earlier in the lifecycle. For performance,
 the AMRMClient may return its internal collection directly without creating
 a copy. Users should not perform mutable operations on the return value.

 NOTE: This API only matches Container requests that were created by the
 client WITH the allocationRequestId being set to a non-default value.

 @param allocationRequestId Allocation Request Id
 @return Collection of request matching the parameters]]>
      </doc>
    </method>
    <method name="updateBlacklist"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blacklistAdditions" type="java.util.List"/>
      <param name="blacklistRemovals" type="java.util.List"/>
      <doc>
      <![CDATA[Update application's blacklist with addition or removal resources.
 
 @param blacklistAdditions list of resources which should be added to the 
        application blacklist
 @param blacklistRemovals list of resources which should be removed from the 
        application blacklist]]>
      </doc>
    </method>
    <method name="setNMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nmTokenCache" type="org.apache.hadoop.yarn.client.api.NMTokenCache"/>
      <doc>
      <![CDATA[Set the NM token cache for the <code>AMRMClient</code>. This cache must
 be shared with the {@link NMClient} used to manage containers for the
 <code>AMRMClient</code>
 <p>
 If a NM token cache is not set, the {@link NMTokenCache#getSingleton()}
 singleton instance will be used.

 @param nmTokenCache the NM token cache to use.]]>
      </doc>
    </method>
    <method name="getNMTokenCache" return="org.apache.hadoop.yarn.client.api.NMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the NM token cache of the <code>AMRMClient</code>. This cache must be
 shared with the {@link NMClient} used to manage containers for the
 <code>AMRMClient</code>.
 <p>
 If a NM token cache is not set, the {@link NMTokenCache#getSingleton()}
 singleton instance will be used.

 @return the NM token cache.]]>
      </doc>
    </method>
    <method name="registerTimelineV2Client"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="client" type="org.apache.hadoop.yarn.client.api.TimelineV2Client"/>
      <doc>
      <![CDATA[Register TimelineV2Client to AMRMClient. Writer's address for the timeline
 V2 client will be updated dynamically if registered.

 @param client the timeline v2 client to register]]>
      </doc>
    </method>
    <method name="getRegisteredTimelineV2Client" return="org.apache.hadoop.yarn.client.api.TimelineV2Client"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get registered timeline v2 client.
 @return the registered timeline v2 client]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each 1000 ms.
 See also {@link #waitFor(com.google.common.base.Supplier, int)}
 and {@link #waitFor(com.google.common.base.Supplier, int, int)}
 @param check the condition for which it should wait]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <param name="checkEveryMillis" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each
 <code>checkEveryMillis</code> ms.
 See also {@link #waitFor(com.google.common.base.Supplier, int, int)}
 @param check user defined checker
 @param checkEveryMillis interval to call <code>check</code>]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <param name="checkEveryMillis" type="int"/>
      <param name="logInterval" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each
 <code>checkEveryMillis</code> ms. In the main loop, this method will log
 the message "waiting in main loop" for each <code>logInterval</code> times
 iteration to confirm the thread is alive.
 @param check user defined checker
 @param checkEveryMillis interval to call <code>check</code>
 @param logInterval interval to log for each]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.AMRMClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.NMClient -->
  <class name="NMClient" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMClient" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createNMClient" return="org.apache.hadoop.yarn.client.api.NMClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of NMClient.]]>
      </doc>
    </method>
    <method name="createNMClient" return="org.apache.hadoop.yarn.client.api.NMClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a new instance of NMClient.]]>
      </doc>
    </method>
    <method name="startContainer" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <param name="containerLaunchContext" type="org.apache.hadoop.yarn.api.records.ContainerLaunchContext"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Start an allocated container.</p>

 <p>The <code>ApplicationMaster</code> or other applications that use the
 client must provide the details of the allocated container, including the
 Id, the assigned node's Id and the token via {@link Container}. In
 addition, the AM needs to provide the {@link ContainerLaunchContext} as
 well.</p>

 @param container the allocated container
 @param containerLaunchContext the context information needed by the
                               <code>NodeManager</code> to launch the
                               container
 @return a map between the auxiliary service names and their outputs
 @throws YarnException YarnException.
 @throws IOException IOException.]]>
      </doc>
    </method>
    <method name="increaseContainerResource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Increase the resource of a container.</p>

 <p>The <code>ApplicationMaster</code> or other applications that use the
 client must provide the details of the container, including the Id and
 the target resource encapsulated in the updated container token via
 {@link Container}.
 </p>

 @param container the container with updated token.

 @throws YarnException YarnException.
 @throws IOException IOException.]]>
      </doc>
    </method>
    <method name="updateContainerResource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Update the resources of a container.</p>

 <p>The <code>ApplicationMaster</code> or other applications that use the
 client must provide the details of the container, including the Id and
 the target resource encapsulated in the updated container token via
 {@link Container}.
 </p>

 @param container the container with updated token.

 @throws YarnException YarnException.
 @throws IOException IOException.]]>
      </doc>
    </method>
    <method name="stopContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Stop an started container.</p>

 @param containerId the Id of the started container
 @param nodeId the Id of the <code>NodeManager</code>

 @throws YarnException YarnException.
 @throws IOException IOException.]]>
      </doc>
    </method>
    <method name="getContainerStatus" return="org.apache.hadoop.yarn.api.records.ContainerStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Query the status of a container.</p>

 @param containerId the Id of the started container
 @param nodeId the Id of the <code>NodeManager</code>
 
 @return the status of a container.

 @throws YarnException YarnException.
 @throws IOException IOException.]]>
      </doc>
    </method>
    <method name="reInitializeContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="containerLaunchContex" type="org.apache.hadoop.yarn.api.records.ContainerLaunchContext"/>
      <param name="autoCommit" type="boolean"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Re-Initialize the Container.</p>

 @param containerId the Id of the container to Re-Initialize.
 @param containerLaunchContex the updated ContainerLaunchContext.
 @param autoCommit commit re-initialization automatically ?

 @throws YarnException YarnException.
 @throws IOException IOException.]]>
      </doc>
    </method>
    <method name="restartContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Restart the specified container.</p>

 @param containerId the Id of the container to restart.

 @throws YarnException YarnException.
 @throws IOException IOException.]]>
      </doc>
    </method>
    <method name="rollbackLastReInitialization"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Rollback last reInitialization of the specified container.</p>

 @param containerId the Id of the container to restart.

 @throws YarnException YarnException.
 @throws IOException IOException.]]>
      </doc>
    </method>
    <method name="commitLastReInitialization"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Commit last reInitialization of the specified container.</p>

 @param containerId the Id of the container to commit reInitialize.

 @throws YarnException YarnException.
 @throws IOException IOException.]]>
      </doc>
    </method>
    <method name="cleanupRunningContainersOnStop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enabled" type="boolean"/>
      <doc>
      <![CDATA[<p>Set whether the containers that are started by this client, and are
 still running should be stopped when the client stops. By default, the
 feature should be enabled.</p> However, containers will be stopped only  
 when service is stopped. i.e. after {@link NMClient#stop()}. 

 @param enabled whether the feature is enabled or not]]>
      </doc>
    </method>
    <method name="setNMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nmTokenCache" type="org.apache.hadoop.yarn.client.api.NMTokenCache"/>
      <doc>
      <![CDATA[Set the NM Token cache of the <code>NMClient</code>. This cache must be
 shared with the {@link AMRMClient} that requested the containers managed
 by this <code>NMClient</code>
 <p>
 If a NM token cache is not set, the {@link NMTokenCache#getSingleton()}
 singleton instance will be used.

 @param nmTokenCache the NM token cache to use.]]>
      </doc>
    </method>
    <method name="getNMTokenCache" return="org.apache.hadoop.yarn.client.api.NMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the NM token cache of the <code>NMClient</code>. This cache must be
 shared with the {@link AMRMClient} that requested the containers managed
 by this <code>NMClient</code>
 <p>
 If a NM token cache is not set, the {@link NMTokenCache#getSingleton()}
 singleton instance will be used.

 @return the NM token cache]]>
      </doc>
    </method>
    <method name="getNodeIdOfStartedContainer" return="org.apache.hadoop.yarn.api.records.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <doc>
      <![CDATA[Get the NodeId of the node on which container is running. It returns
 null if the container if container is not found or if it is not running.

 @param containerId Container Id of the container.
 @return NodeId of the container on which it is running.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.NMClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.NMTokenCache -->
  <class name="NMTokenCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMTokenCache"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a NM token cache instance.]]>
      </doc>
    </constructor>
    <method name="getSingleton" return="org.apache.hadoop.yarn.client.api.NMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the singleton NM token cache.

 @return the singleton NM token cache.]]>
      </doc>
    </method>
    <method name="getNMToken" return="org.apache.hadoop.yarn.api.records.Token"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeAddr" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns NMToken, null if absent. Only the singleton obtained from
 {@link #getSingleton()} is looked at for the tokens. If you are using your
 own NMTokenCache that is different from the singleton, use
 {@link #getToken(String) }
 
 @param nodeAddr
 @return {@link Token} NMToken required for communicating with node manager]]>
      </doc>
    </method>
    <method name="setNMToken"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeAddr" type="java.lang.String"/>
      <param name="token" type="org.apache.hadoop.yarn.api.records.Token"/>
      <doc>
      <![CDATA[Sets the NMToken for node address only in the singleton obtained from
 {@link #getSingleton()}. If you are using your own NMTokenCache that is
 different from the singleton, use {@link #setToken(String, Token) }
 
 @param nodeAddr
          node address (host:port)
 @param token
          NMToken]]>
      </doc>
    </method>
    <method name="getToken" return="org.apache.hadoop.yarn.api.records.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeAddr" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns NMToken, null if absent
 @param nodeAddr
 @return {@link Token} NMToken required for communicating with node
         manager]]>
      </doc>
    </method>
    <method name="setToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeAddr" type="java.lang.String"/>
      <param name="token" type="org.apache.hadoop.yarn.api.records.Token"/>
      <doc>
      <![CDATA[Sets the NMToken for node address
 @param nodeAddr node address (host:port)
 @param token NMToken]]>
      </doc>
    </method>
    <doc>
    <![CDATA[NMTokenCache manages NMTokens required for an Application Master
 communicating with individual NodeManagers.
 <p>
 By default Yarn client libraries {@link AMRMClient} and {@link NMClient} use
 {@link #getSingleton()} instance of the cache.
 <ul>
   <li>
     Using the singleton instance of the cache is appropriate when running a
     single ApplicationMaster in the same JVM.
   </li>
   <li>
     When using the singleton, users don't need to do anything special,
     {@link AMRMClient} and {@link NMClient} are already set up to use the
     default singleton {@link NMTokenCache}
     </li>
 </ul>
 If running multiple Application Masters in the same JVM, a different cache
 instance should be used for each Application Master.
 <ul>
   <li>
     If using the {@link AMRMClient} and the {@link NMClient}, setting up
     and using an instance cache is as follows:
 <pre>
   NMTokenCache nmTokenCache = new NMTokenCache();
   AMRMClient rmClient = AMRMClient.createAMRMClient();
   NMClient nmClient = NMClient.createNMClient();
   nmClient.setNMTokenCache(nmTokenCache);
   ...
 </pre>
   </li>
   <li>
     If using the {@link AMRMClientAsync} and the {@link NMClientAsync},
     setting up and using an instance cache is as follows:
 <pre>
   NMTokenCache nmTokenCache = new NMTokenCache();
   AMRMClient rmClient = AMRMClient.createAMRMClient();
   NMClient nmClient = NMClient.createNMClient();
   nmClient.setNMTokenCache(nmTokenCache);
   AMRMClientAsync rmClientAsync = new AMRMClientAsync(rmClient, 1000, [AMRM_CALLBACK]);
   NMClientAsync nmClientAsync = new NMClientAsync("nmClient", nmClient, [NM_CALLBACK]);
   ...
 </pre>
   </li>
   <li>
     If using {@link ApplicationMasterProtocol} and
     {@link ContainerManagementProtocol} directly, setting up and using an
     instance cache is as follows:
 <pre>
   NMTokenCache nmTokenCache = new NMTokenCache();
   ...
   ApplicationMasterProtocol amPro = ClientRMProxy.createRMProxy(conf, ApplicationMasterProtocol.class);
   ...
   AllocateRequest allocateRequest = ...
   ...
   AllocateResponse allocateResponse = rmClient.allocate(allocateRequest);
   for (NMToken token : allocateResponse.getNMTokens()) {
     nmTokenCache.setToken(token.getNodeId().toString(), token.getToken());
   }
   ...
   ContainerManagementProtocolProxy nmPro = ContainerManagementProtocolProxy(conf, nmTokenCache);
   ...
   nmPro.startContainer(container, containerContext);
   ...
 </pre>
   </li>
 </ul>
 It is also possible to mix the usage of a client ({@code AMRMClient} or
 {@code NMClient}, or the async versions of them) with a protocol proxy
 ({@code ContainerManagementProtocolProxy} or
 {@code ApplicationMasterProtocol}).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.NMTokenCache -->
  <!-- start class org.apache.hadoop.yarn.client.api.SharedCacheClient -->
  <class name="SharedCacheClient" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SharedCacheClient" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createSharedCacheClient" return="org.apache.hadoop.yarn.client.api.SharedCacheClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="use" return="org.apache.hadoop.yarn.api.records.URL"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="resourceKey" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 The method to claim a resource with the <code>SharedCacheManager.</code>
 The client uses a checksum to identify the resource and an
 {@link ApplicationId} to identify which application will be using the
 resource.
 </p>

 <p>
 The <code>SharedCacheManager</code> responds with whether or not the
 resource exists in the cache. If the resource exists, a <code>URL</code> to
 the resource in the shared cache is returned. If the resource does not
 exist, null is returned instead.
 </p>

 <p>
 Once a URL has been returned for a resource, that URL is safe to use for
 the lifetime of the application that corresponds to the provided
 ApplicationId.
 </p>

 @param applicationId ApplicationId of the application using the resource
 @param resourceKey the key (i.e. checksum) that identifies the resource
 @return URL to the resource, or null if it does not exist]]>
      </doc>
    </method>
    <method name="release"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="resourceKey" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 The method to release a resource with the <code>SharedCacheManager.</code>
 This method is called once an application is no longer using a claimed
 resource in the shared cache. The client uses a checksum to identify the
 resource and an {@link ApplicationId} to identify which application is
 releasing the resource.
 </p>
 
 <p>
 Note: This method is an optimization and the client is not required to call
 it for correctness.
 </p>
 
 @param applicationId ApplicationId of the application releasing the
          resource
 @param resourceKey the key (i.e. checksum) that identifies the resource]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A convenience method to calculate the checksum of a specified file.
 
 @param sourceFile A path to the input file
 @return A hex string containing the checksum digest
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is the client for YARN's shared cache.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.SharedCacheClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.YarnClient -->
  <class name="YarnClient" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="YarnClient" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createYarnClient" return="org.apache.hadoop.yarn.client.api.YarnClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of YarnClient.]]>
      </doc>
    </method>
    <method name="createApplication" return="org.apache.hadoop.yarn.client.api.YarnClientApplication"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Obtain a {@link YarnClientApplication} for a new application,
 which in turn contains the {@link ApplicationSubmissionContext} and
 {@link org.apache.hadoop.yarn.api.protocolrecords.GetNewApplicationResponse}
 objects.
 </p>

 @return {@link YarnClientApplication} built for a new application
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="submitApplication" return="org.apache.hadoop.yarn.api.records.ApplicationId"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appContext" type="org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Submit a new application to <code>YARN.</code> It is a blocking call - it
 will not return {@link ApplicationId} until the submitted application is
 submitted successfully and accepted by the ResourceManager.
 </p>
 
 <p>
 Users should provide an {@link ApplicationId} as part of the parameter
 {@link ApplicationSubmissionContext} when submitting a new application,
 otherwise it will throw the {@link ApplicationIdNotProvidedException}.
 </p>

 <p>This internally calls {@link ApplicationClientProtocol#submitApplication
 (SubmitApplicationRequest)}, and after that, it internally invokes
 {@link ApplicationClientProtocol#getApplicationReport
 (GetApplicationReportRequest)} and waits till it can make sure that the
 application gets properly submitted. If RM fails over or RM restart
 happens before ResourceManager saves the application's state,
 {@link ApplicationClientProtocol
 #getApplicationReport(GetApplicationReportRequest)} will throw
 the {@link ApplicationNotFoundException}. This API automatically resubmits
 the application with the same {@link ApplicationSubmissionContext} when it
 catches the {@link ApplicationNotFoundException}</p>

 @param appContext
          {@link ApplicationSubmissionContext} containing all the details
          needed to submit a new application
 @return {@link ApplicationId} of the accepted application
 @throws YarnException
 @throws IOException
 @see #createApplication()]]>
      </doc>
    </method>
    <method name="failApplicationAttempt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Fail an application attempt identified by given ID.
 </p>

 @param applicationAttemptId
          {@link ApplicationAttemptId} of the attempt to fail.
 @throws YarnException
           in case of errors or if YARN rejects the request due to
           access-control restrictions.
 @throws IOException
 @see #getQueueAclsInfo()]]>
      </doc>
    </method>
    <method name="killApplication"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Kill an application identified by given ID.
 </p>
 
 @param applicationId
          {@link ApplicationId} of the application that needs to be killed
 @throws YarnException
           in case of errors or if YARN rejects the request due to
           access-control restrictions.
 @throws IOException
 @see #getQueueAclsInfo()]]>
      </doc>
    </method>
    <method name="killApplication"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="diagnostics" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Kill an application identified by given ID.
 </p>
 @param applicationId {@link ApplicationId} of the application that needs to
          be killed
 @param diagnostics for killing an application.
 @throws YarnException in case of errors or if YARN rejects the request due
           to access-control restrictions.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationReport" return="org.apache.hadoop.yarn.api.records.ApplicationReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given Application.
 </p>
 
 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>
 
 <p>
 If the user does not have <code>VIEW_APP</code> access then the following
 fields in the report will be set to stubbed values:
 <ul>
 <li>host - set to "N/A"</li>
 <li>RPC port - set to -1</li>
 <li>client token - set to "N/A"</li>
 <li>diagnostics - set to "N/A"</li>
 <li>tracking URL - set to "N/A"</li>
 <li>original tracking URL - set to "N/A"</li>
 <li>resource usage report - all values are -1</li>
 </ul>
 
 @param appId
          {@link ApplicationId} of the application that needs a report
 @return application report
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getAMRMToken" return="org.apache.hadoop.security.token.Token"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the AMRM token of the application.
 <p>
 The AMRM token is required for AM to RM scheduling operations. For 
 managed Application Masters Yarn takes care of injecting it. For unmanaged
 Applications Masters, the token must be obtained via this method and set
 in the {@link org.apache.hadoop.security.UserGroupInformation} of the
 current user.
 <p>
 The AMRM token will be returned only if all the following conditions are
 met:
 <ul>
   <li>the requester is the owner of the ApplicationMaster</li>
   <li>the application master is an unmanaged ApplicationMaster</li>
   <li>the application master is in ACCEPTED state</li>
 </ul>
 Else this method returns NULL.

 @param appId {@link ApplicationId} of the application to get the AMRM token
 @return the AMRM token if available
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of all Applications in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @return a list of reports of all running applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationTypes" type="java.util.Set"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of Applications
 matching the given application types in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @param applicationTypes set of application types you are interested in
 @return a list of reports of applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationStates" type="java.util.EnumSet"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of Applications matching the given
 application states in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @param applicationStates set of application states you are interested in
 @return a list of reports of applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationTypes" type="java.util.Set"/>
      <param name="applicationStates" type="java.util.EnumSet"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of Applications matching the given
 application types and application states in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @param applicationTypes set of application types you are interested in
 @param applicationStates set of application states you are interested in
 @return a list of reports of applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationTypes" type="java.util.Set"/>
      <param name="applicationStates" type="java.util.EnumSet"/>
      <param name="applicationTags" type="java.util.Set"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of Applications matching the given
 application types, application states and application tags in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @param applicationTypes set of application types you are interested in
 @param applicationStates set of application states you are interested in
 @param applicationTags set of application tags you are interested in
 @return a list of reports of applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queues" type="java.util.Set"/>
      <param name="users" type="java.util.Set"/>
      <param name="applicationTypes" type="java.util.Set"/>
      <param name="applicationStates" type="java.util.EnumSet"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of Applications matching the given users,
 queues, application types and application states in the cluster. If any of
 the params is set to null, it is not used when filtering.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @param queues set of queues you are interested in
 @param users set of users you are interested in
 @param applicationTypes set of application types you are interested in
 @param applicationStates set of application states you are interested in
 @return a list of reports of applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.api.protocolrecords.GetApplicationsRequest"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a list of ApplicationReports that match the given
 {@link GetApplicationsRequest}.
</p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @param request the request object to get the list of applications.
 @return The list of ApplicationReports that match the request
 @throws YarnException Exception specific to YARN.
 @throws IOException Exception mostly related to connection errors.]]>
      </doc>
    </method>
    <method name="getYarnClusterMetrics" return="org.apache.hadoop.yarn.api.records.YarnClusterMetrics"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get metrics ({@link YarnClusterMetrics}) about the cluster.
 </p>
 
 @return cluster metrics
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getNodeReports" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="states" type="org.apache.hadoop.yarn.api.records.NodeState[]"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of nodes ({@link NodeReport}) in the cluster.
 </p>
 
 @param states The {@link NodeState}s to filter on. If no filter states are
          given, nodes in all states will be returned.
 @return A list of node reports
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getRMDelegationToken" return="org.apache.hadoop.yarn.api.records.Token"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="org.apache.hadoop.io.Text"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a delegation token so as to be able to talk to YARN using those tokens.
 
 @param renewer
          Address of the renewer who can renew these tokens when needed by
          securely talking to YARN.
 @return a delegation token ({@link Token}) that can be used to
         talk to YARN
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getQueueInfo" return="org.apache.hadoop.yarn.api.records.QueueInfo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueName" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information ({@link QueueInfo}) about a given <em>queue</em>.
 </p>
 
 @param queueName
          Name of the queue whose information is needed
 @return queue information
 @throws YarnException
           in case of errors or if YARN rejects the request due to
           access-control restrictions.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getAllQueues" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information ({@link QueueInfo}) about all queues, recursively if there
 is a hierarchy
 </p>
 
 @return a list of queue-information for all queues
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getRootQueueInfos" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information ({@link QueueInfo}) about top level queues.
 </p>
 
 @return a list of queue-information for all the top-level queues
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getChildQueueInfos" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information ({@link QueueInfo}) about all the immediate children queues
 of the given queue
 </p>
 
 @param parent
          Name of the queue whose child-queues' information is needed
 @return a list of queue-information for all queues who are direct children
         of the given parent queue.
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getQueueAclsInfo" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information about <em>acls</em> for <em>current user</em> on all the
 existing queues.
 </p>
 
 @return a list of queue acls ({@link QueueUserACLInfo}) for
         <em>current user</em>
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttemptReport" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given ApplicationAttempt.
 </p>
 
 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>
 
 @param applicationAttemptId
          {@link ApplicationAttemptId} of the application attempt that needs
          a report
 @return application attempt report
 @throws YarnException
 @throws ApplicationAttemptNotFoundException if application attempt
         not found
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttempts" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of all (ApplicationAttempts) of Application in the cluster.
 </p>
 
 @param applicationId application id of the app
 @return a list of reports for all application attempts for specified
         application.
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainerReport" return="org.apache.hadoop.yarn.api.records.ContainerReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given Container.
 </p>
 
 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>
 
 @param containerId
          {@link ContainerId} of the container that needs a report
 @return container report
 @throws YarnException
 @throws ContainerNotFoundException if container not found.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainers" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of all (Containers) of ApplicationAttempt in the cluster.
 </p>
 
 @param applicationAttemptId application attempt id
 @return a list of reports of all containers for specified application
         attempts
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="moveApplicationAcrossQueues"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="queue" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Attempts to move the given application to the given queue.
 </p>
 
 @param appId
    Application to move.
 @param queue
    Queue to place it in to.
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="createReservation" return="org.apache.hadoop.yarn.api.protocolrecords.GetNewReservationResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Obtain a {@link GetNewReservationResponse} for a new reservation,
 which contains the {@link ReservationId} object.
 </p>

 @return The {@link GetNewReservationResponse} containing a new
         {@link ReservationId} object.
 @throws YarnException if reservation cannot be created.
 @throws IOException if reservation cannot be created.]]>
      </doc>
    </method>
    <method name="submitReservation" return="org.apache.hadoop.yarn.api.protocolrecords.ReservationSubmissionResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.api.protocolrecords.ReservationSubmissionRequest"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by clients to submit a new reservation to the
 {@code ResourceManager}.
 </p>
 
 <p>
 The client packages all details of its request in a
 {@link ReservationSubmissionRequest} object. This contains information
 about the amount of capacity, temporal constraints, and gang needs.
 Furthermore, the reservation might be composed of multiple stages, with
 ordering dependencies among them.
 </p>
 
 <p>
 In order to respond, a new admission control component in the
 {@code ResourceManager} performs an analysis of the resources that have
 been committed over the period of time the user is requesting, verify that
 the user requests can be fulfilled, and that it respect a sharing policy
 (e.g., {@code CapacityOverTimePolicy}). Once it has positively determined
 that the ReservationRequest is satisfiable the {@code ResourceManager}
 answers with a {@link ReservationSubmissionResponse} that includes a
 {@link ReservationId}. Upon failure to find a valid allocation the response
 is an exception with the message detailing the reason of failure.
 </p>
 
 <p>
 The semantics guarantees that the {@link ReservationId} returned,
 corresponds to a valid reservation existing in the time-range request by
 the user. The amount of capacity dedicated to such reservation can vary
 overtime, depending of the allocation that has been determined. But it is
 guaranteed to satisfy all the constraint expressed by the user in the
 {@link ReservationDefinition}
 </p>
 
 @param request request to submit a new Reservation
 @return response contains the {@link ReservationId} on accepting the
         submission
 @throws YarnException if the reservation cannot be created successfully
 @throws IOException]]>
      </doc>
    </method>
    <method name="updateReservation" return="org.apache.hadoop.yarn.api.protocolrecords.ReservationUpdateResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.api.protocolrecords.ReservationUpdateRequest"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by clients to update an existing Reservation. This is
 referred to as a re-negotiation process, in which a user that has
 previously submitted a Reservation.
 </p>
 
 <p>
 The allocation is attempted by virtually substituting all previous
 allocations related to this Reservation with new ones, that satisfy the new
 {@link ReservationDefinition}. Upon success the previous allocation is
 atomically substituted by the new one, and on failure (i.e., if the system
 cannot find a valid allocation for the updated request), the previous
 allocation remains valid.
 </p>
 
 @param request to update an existing Reservation (the
          {@link ReservationUpdateRequest} should refer to an existing valid
          {@link ReservationId})
 @return response empty on successfully updating the existing reservation
 @throws YarnException if the request is invalid or reservation cannot be
           updated successfully
 @throws IOException]]>
      </doc>
    </method>
    <method name="deleteReservation" return="org.apache.hadoop.yarn.api.protocolrecords.ReservationDeleteResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.api.protocolrecords.ReservationDeleteRequest"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by clients to remove an existing Reservation.
 </p>
 
 @param request to remove an existing Reservation (the
          {@link ReservationDeleteRequest} should refer to an existing valid
          {@link ReservationId})
 @return response empty on successfully deleting the existing reservation
 @throws YarnException if the request is invalid or reservation cannot be
           deleted successfully
 @throws IOException]]>
      </doc>
    </method>
    <method name="listReservations" return="org.apache.hadoop.yarn.api.protocolrecords.ReservationListResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.api.protocolrecords.ReservationListRequest"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by clients to get the list of reservations in a plan.
 The reservationId will be used to search for reservations to list if it is
 provided. Otherwise, it will select active reservations within the
 startTime and endTime (inclusive).
 </p>

 @param request to list reservations in a plan. Contains fields to select
                String queue, ReservationId reservationId, long startTime,
                long endTime, and a bool includeReservationAllocations.

                queue: Required. Cannot be null or empty. Refers to the
                reservable queue in the scheduler that was selected when
                creating a reservation submission
                {@link ReservationSubmissionRequest}.

                reservationId: Optional. If provided, other fields will
                be ignored.

                startTime: Optional. If provided, only reservations that
                end after the startTime will be selected. This defaults
                to 0 if an invalid number is used.

                endTime: Optional. If provided, only reservations that
                start on or before endTime will be selected. This defaults
                to Long.MAX_VALUE if an invalid number is used.

                includeReservationAllocations: Optional. Flag that
                determines whether the entire reservation allocations are
                to be returned. Reservation allocations are subject to
                change in the event of re-planning as described by
                {@link ReservationDefinition}.

 @return response that contains information about reservations that are
                being searched for.
 @throws YarnException if the request is invalid
 @throws IOException if the request failed otherwise]]>
      </doc>
    </method>
    <method name="getNodeToLabels" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by client to get node to labels mappings in existing cluster
 </p>
 
 @return node to labels mappings
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getLabelsToNodes" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by client to get labels to nodes mapping
 in existing cluster
 </p>

 @return node to labels mappings
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getLabelsToNodes" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="labels" type="java.util.Set"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by client to get labels to nodes mapping
 for specified labels in existing cluster
 </p>

 @param labels labels for which labels to nodes mapping has to be retrieved
 @return labels to nodes mappings for specific labels
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getClusterNodeLabels" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by client to get node labels in the cluster
 </p>

 @return cluster node labels collection
 @throws YarnException when there is a failure in
           {@link ApplicationClientProtocol}
 @throws IOException when there is a failure in
           {@link ApplicationClientProtocol}]]>
      </doc>
    </method>
    <method name="updateApplicationPriority" return="org.apache.hadoop.yarn.api.records.Priority"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="priority" type="org.apache.hadoop.yarn.api.records.Priority"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by client to set priority of an application
 </p>
 @param applicationId
 @param priority
 @return updated priority of an application.
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="signalToContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="command" type="org.apache.hadoop.yarn.api.records.SignalContainerCommand"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Signal a container identified by given ID.
 </p>

 @param containerId
          {@link ContainerId} of the container that needs to be signaled
 @param command the signal container command
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="updateApplicationTimeouts" return="org.apache.hadoop.yarn.api.protocolrecords.UpdateApplicationTimeoutsResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.api.protocolrecords.UpdateApplicationTimeoutsRequest"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.YarnClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.YarnClientApplication -->
  <class name="YarnClientApplication" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="YarnClientApplication" type="org.apache.hadoop.yarn.api.protocolrecords.GetNewApplicationResponse, org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNewApplicationResponse" return="org.apache.hadoop.yarn.api.protocolrecords.GetNewApplicationResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getApplicationSubmissionContext" return="org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.YarnClientApplication -->
</package>
<package name="org.apache.hadoop.yarn.client.api.async">
  <!-- start class org.apache.hadoop.yarn.client.api.async.AMRMClientAsync -->
  <class name="AMRMClientAsync" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AMRMClientAsync" type="int, org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.AbstractCallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AMRMClientAsync" type="org.apache.hadoop.yarn.client.api.AMRMClient, int, org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.AbstractCallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AMRMClientAsync" type="int, org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AMRMClientAsync" type="org.apache.hadoop.yarn.client.api.AMRMClient, int, org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createAMRMClientAsync" return="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="intervalMs" type="int"/>
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.AbstractCallbackHandler"/>
      <doc>
      <![CDATA[<p>Create a new instance of AMRMClientAsync.</p>

 @param intervalMs heartbeat interval in milliseconds between AM and RM
 @param callbackHandler callback handler that processes responses from
                        the <code>ResourceManager</code>]]>
      </doc>
    </method>
    <method name="createAMRMClientAsync" return="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="client" type="org.apache.hadoop.yarn.client.api.AMRMClient"/>
      <param name="intervalMs" type="int"/>
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.AbstractCallbackHandler"/>
      <doc>
      <![CDATA[<p>Create a new instance of AMRMClientAsync.</p>

 @param client the AMRMClient instance
 @param intervalMs heartbeat interval in milliseconds between AM and RM
 @param callbackHandler callback handler that processes responses from
                        the <code>ResourceManager</code>]]>
      </doc>
    </method>
    <method name="createAMRMClientAsync" return="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createAMRMClientAsync(int,
             AMRMClientAsync.AbstractCallbackHandler)} instead.">
      <param name="intervalMs" type="int"/>
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"/>
      <doc>
      <![CDATA[@deprecated Use {@link #createAMRMClientAsync(int,
             AMRMClientAsync.AbstractCallbackHandler)} instead.]]>
      </doc>
    </method>
    <method name="createAMRMClientAsync" return="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createAMRMClientAsync(AMRMClient,
             int, AMRMClientAsync.AbstractCallbackHandler)} instead.">
      <param name="client" type="org.apache.hadoop.yarn.client.api.AMRMClient"/>
      <param name="intervalMs" type="int"/>
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"/>
      <doc>
      <![CDATA[@deprecated Use {@link #createAMRMClientAsync(AMRMClient,
             int, AMRMClientAsync.AbstractCallbackHandler)} instead.]]>
      </doc>
    </method>
    <method name="setHeartbeatInterval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interval" type="int"/>
    </method>
    <method name="getMatchingRequests" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="org.apache.hadoop.yarn.api.records.Priority"/>
      <param name="resourceName" type="java.lang.String"/>
      <param name="capability" type="org.apache.hadoop.yarn.api.records.Resource"/>
    </method>
    <method name="getMatchingRequests" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="org.apache.hadoop.yarn.api.records.Priority"/>
      <param name="resourceName" type="java.lang.String"/>
      <param name="executionType" type="org.apache.hadoop.yarn.api.records.ExecutionType"/>
      <param name="capability" type="org.apache.hadoop.yarn.api.records.Resource"/>
      <doc>
      <![CDATA[Returns all matching ContainerRequests that match the given Priority,
 ResourceName, ExecutionType and Capability.

 NOTE: This matches only requests that were made by the client WITHOUT the
 allocationRequestId specified.

 @param priority Priority.
 @param resourceName Location.
 @param executionType ExecutionType.
 @param capability Capability.
 @return All matching ContainerRequests]]>
      </doc>
    </method>
    <method name="getMatchingRequests" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allocationRequestId" type="long"/>
      <doc>
      <![CDATA[Returns all matching ContainerRequests that match the given
 AllocationRequestId.

 NOTE: This matches only requests that were made by the client WITH the
 allocationRequestId specified.

 @param allocationRequestId AllocationRequestId.
 @return All matching ContainerRequests]]>
      </doc>
    </method>
    <method name="registerApplicationMaster" return="org.apache.hadoop.yarn.api.protocolrecords.RegisterApplicationMasterResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appHostName" type="java.lang.String"/>
      <param name="appHostPort" type="int"/>
      <param name="appTrackingUrl" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Registers this application master with the resource manager. On successful
 registration, starts the heartbeating thread.
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="unregisterApplicationMaster"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appStatus" type="org.apache.hadoop.yarn.api.records.FinalApplicationStatus"/>
      <param name="appMessage" type="java.lang.String"/>
      <param name="appTrackingUrl" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unregister the application master. This must be called in the end.
 @param appStatus Success/Failure status of the master
 @param appMessage Diagnostics message on failure
 @param appTrackingUrl New URL to get master info
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="addContainerRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="req" type="T"/>
      <doc>
      <![CDATA[Request containers for resources before calling <code>allocate</code>
 @param req Resource request]]>
      </doc>
    </method>
    <method name="removeContainerRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="req" type="T"/>
      <doc>
      <![CDATA[Remove previous container request. The previous container request may have 
 already been sent to the ResourceManager. So even after the remove request 
 the app must be prepared to receive an allocation for the previous request 
 even after the remove request
 @param req Resource request]]>
      </doc>
    </method>
    <method name="requestContainerResourceChange"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use
 {@link #requestContainerUpdate(Container, UpdateContainerRequest)}">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <param name="capability" type="org.apache.hadoop.yarn.api.records.Resource"/>
      <doc>
      <![CDATA[Request container resource change before calling <code>allocate</code>.
 Any previous pending resource change request of the same container will be
 removed.

 Application that calls this method is expected to maintain the
 <code>Container</code>s that are returned from previous successful
 allocations or resource changes. By passing in the existing container and a
 target resource capability to this method, the application requests the
 ResourceManager to change the existing resource allocation to the target
 resource allocation.

 @deprecated use
 {@link #requestContainerUpdate(Container, UpdateContainerRequest)}

 @param container The container returned from the last successful resource
                  allocation or resource change
 @param capability  The target resource capability of the container]]>
      </doc>
    </method>
    <method name="requestContainerUpdate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <param name="updateContainerRequest" type="org.apache.hadoop.yarn.api.records.UpdateContainerRequest"/>
      <doc>
      <![CDATA[Request a container update before calling <code>allocate</code>.
 Any previous pending update request of the same container will be
 removed.

 @param container The container returned from the last successful resource
                  allocation or update
 @param updateContainerRequest The <code>UpdateContainerRequest</code>.]]>
      </doc>
    </method>
    <method name="releaseAssignedContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <doc>
      <![CDATA[Release containers assigned by the Resource Manager. If the app cannot use
 the container or wants to give up the container then it can release them.
 The app needs to make new requests for the released resource capability if
 it still needs it. eg. it released non-local resources
 @param containerId]]>
      </doc>
    </method>
    <method name="getAvailableResources" return="org.apache.hadoop.yarn.api.records.Resource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the currently available resources in the cluster.
 A valid value is available after a call to allocate has been made
 @return Currently available resources]]>
      </doc>
    </method>
    <method name="getClusterNodeCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current number of nodes in the cluster.
 A valid values is available after a call to allocate has been made
 @return Current number of nodes in the cluster]]>
      </doc>
    </method>
    <method name="registerTimelineV2Client"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timelineClient" type="org.apache.hadoop.yarn.client.api.TimelineV2Client"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[Register TimelineClient to AMRMClient.
 @param timelineClient
 @throws YarnException when this method is invoked even when ATS V2 is not
           configured.]]>
      </doc>
    </method>
    <method name="getRegisteredTimelineV2Client" return="org.apache.hadoop.yarn.client.api.TimelineV2Client"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get registered timeline client.
 @return the registered timeline client]]>
      </doc>
    </method>
    <method name="updateBlacklist"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blacklistAdditions" type="java.util.List"/>
      <param name="blacklistRemovals" type="java.util.List"/>
      <doc>
      <![CDATA[Update application's blacklist with addition or removal resources.

 @param blacklistAdditions list of resources which should be added to the
        application blacklist
 @param blacklistRemovals list of resources which should be removed from the
        application blacklist]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each 1000 ms.
 See also {@link #waitFor(com.google.common.base.Supplier, int)}
 and {@link #waitFor(com.google.common.base.Supplier, int, int)}
 @param check the condition for which it should wait]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <param name="checkEveryMillis" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each
 <code>checkEveryMillis</code> ms.
 See also {@link #waitFor(com.google.common.base.Supplier, int, int)}
 @param check user defined checker
 @param checkEveryMillis interval to call <code>check</code>]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <param name="checkEveryMillis" type="int"/>
      <param name="logInterval" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each
 <code>checkEveryMillis</code> ms. In the main loop, this method will log
 the message "waiting in main loop" for each <code>logInterval</code> times
 iteration to confirm the thread is alive.
 @param check user defined checker
 @param checkEveryMillis interval to call <code>check</code>
 @param logInterval interval to log for each]]>
      </doc>
    </method>
    <field name="client" type="org.apache.hadoop.yarn.client.api.AMRMClient"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="handler" type="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="heartbeatIntervalMs" type="java.util.concurrent.atomic.AtomicInteger"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[<code>AMRMClientAsync</code> handles communication with the ResourceManager
 and provides asynchronous updates on events such as container allocations and
 completions.  It contains a thread that sends periodic heartbeats to the
 ResourceManager.
 
 It should be used by implementing a CallbackHandler:
 <pre>
 {@code
 class MyCallbackHandler extends AMRMClientAsync.AbstractCallbackHandler {
   public void onContainersAllocated(List<Container> containers) {
     [run tasks on the containers]
   }

   public void onContainersUpdated(List<Container> containers) {
     [determine if resource allocation of containers have been increased in
      the ResourceManager, and if so, inform the NodeManagers to increase the
      resource monitor/enforcement on the containers]
   }

   public void onContainersCompleted(List<ContainerStatus> statuses) {
     [update progress, check whether app is done]
   }
   
   public void onNodesUpdated(List<NodeReport> updated) {}
   
   public void onReboot() {}
 }
 }
 </pre>
 
 The client's lifecycle should be managed similarly to the following:
 
 <pre>
 {@code
 AMRMClientAsync asyncClient = 
     createAMRMClientAsync(appAttId, 1000, new MyCallbackhandler());
 asyncClient.init(conf);
 asyncClient.start();
 RegisterApplicationMasterResponse response = asyncClient
    .registerApplicationMaster(appMasterHostname, appMasterRpcPort,
       appMasterTrackingUrl);
 asyncClient.addContainerRequest(containerRequest);
 [... wait for application to complete]
 asyncClient.unregisterApplicationMaster(status, appMsg, trackingUrl);
 asyncClient.stop();
 }
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.AMRMClientAsync -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.NMClientAsync -->
  <class name="NMClientAsync" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMClientAsync" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.AbstractCallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NMClientAsync" type="java.lang.String, org.apache.hadoop.yarn.client.api.async.NMClientAsync.AbstractCallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NMClientAsync" type="java.lang.String, org.apache.hadoop.yarn.client.api.NMClient, org.apache.hadoop.yarn.client.api.async.NMClientAsync.AbstractCallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NMClientAsync" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="Use {@link #NMClientAsync(AbstractCallbackHandler)}
             instead.">
      <doc>
      <![CDATA[@deprecated Use {@link #NMClientAsync(AbstractCallbackHandler)}
             instead.]]>
      </doc>
    </constructor>
    <constructor name="NMClientAsync" type="java.lang.String, org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="Use {@link #NMClientAsync(String, AbstractCallbackHandler)}
             instead.">
      <doc>
      <![CDATA[@deprecated Use {@link #NMClientAsync(String, AbstractCallbackHandler)}
             instead.]]>
      </doc>
    </constructor>
    <constructor name="NMClientAsync" type="java.lang.String, org.apache.hadoop.yarn.client.api.NMClient, org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createNMClientAsync" return="org.apache.hadoop.yarn.client.api.async.NMClientAsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.AbstractCallbackHandler"/>
    </method>
    <method name="createNMClientAsync" return="org.apache.hadoop.yarn.client.api.async.NMClientAsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createNMClientAsync(AbstractCallbackHandler)}
             instead.">
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"/>
      <doc>
      <![CDATA[@deprecated Use {@link #createNMClientAsync(AbstractCallbackHandler)}
             instead.]]>
      </doc>
    </method>
    <method name="startContainerAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <param name="containerLaunchContext" type="org.apache.hadoop.yarn.api.records.ContainerLaunchContext"/>
    </method>
    <method name="increaseContainerResourceAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
    </method>
    <method name="updateContainerResourceAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <doc>
      <![CDATA[<p>Update the resources of a container.</p>

 <p>The <code>ApplicationMaster</code> or other applications that use the
 client must provide the details of the container, including the Id and
 the target resource encapsulated in the updated container token via
 {@link Container}.
 </p>

 @param container the container with updated token.]]>
      </doc>
    </method>
    <method name="reInitializeContainerAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="containerLaunchContex" type="org.apache.hadoop.yarn.api.records.ContainerLaunchContext"/>
      <param name="autoCommit" type="boolean"/>
      <doc>
      <![CDATA[<p>Re-Initialize the Container.</p>

 @param containerId the Id of the container to Re-Initialize.
 @param containerLaunchContex the updated ContainerLaunchContext.
 @param autoCommit commit re-initialization automatically ?]]>
      </doc>
    </method>
    <method name="restartContainerAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <doc>
      <![CDATA[<p>Restart the specified container.</p>

 @param containerId the Id of the container to restart.]]>
      </doc>
    </method>
    <method name="rollbackLastReInitializationAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <doc>
      <![CDATA[<p>Rollback last reInitialization of the specified container.</p>

 @param containerId the Id of the container to restart.]]>
      </doc>
    </method>
    <method name="commitLastReInitializationAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <doc>
      <![CDATA[<p>Commit last reInitialization of the specified container.</p>

 @param containerId the Id of the container to commit reInitialize.]]>
      </doc>
    </method>
    <method name="stopContainerAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
    </method>
    <method name="getContainerStatusAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
    </method>
    <method name="getClient" return="org.apache.hadoop.yarn.client.api.NMClient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setClient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="client" type="org.apache.hadoop.yarn.client.api.NMClient"/>
    </method>
    <method name="getCallbackHandler" return="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCallbackHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"/>
    </method>
    <field name="client" type="org.apache.hadoop.yarn.client.api.NMClient"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[<code>NMClientAsync</code> handles communication with all the NodeManagers
 and provides asynchronous updates on getting responses from them. It
 maintains a thread pool to communicate with individual NMs where a number of
 worker threads process requests to NMs by using {@link NMClientImpl}. The max
 size of the thread pool is configurable through
 {@link YarnConfiguration#NM_CLIENT_ASYNC_THREAD_POOL_MAX_SIZE}.

 It should be used in conjunction with a CallbackHandler. For example

 <pre>
 {@code
 class MyCallbackHandler extends NMClientAsync.AbstractCallbackHandler {
   public void onContainerStarted(ContainerId containerId,
       Map<String, ByteBuffer> allServiceResponse) {
     [post process after the container is started, process the response]
   }

   public void onContainerResourceIncreased(ContainerId containerId,
       Resource resource) {
     [post process after the container resource is increased]
   }

   public void onContainerStatusReceived(ContainerId containerId,
       ContainerStatus containerStatus) {
     [make use of the status of the container]
   }

   public void onContainerStopped(ContainerId containerId) {
     [post process after the container is stopped]
   }

   public void onStartContainerError(
       ContainerId containerId, Throwable t) {
     [handle the raised exception]
   }

   public void onGetContainerStatusError(
       ContainerId containerId, Throwable t) {
     [handle the raised exception]
   }

   public void onStopContainerError(
       ContainerId containerId, Throwable t) {
     [handle the raised exception]
   }
 }
 }
 </pre>

 The client's life-cycle should be managed like the following:

 <pre>
 {@code
 NMClientAsync asyncClient = 
     NMClientAsync.createNMClientAsync(new MyCallbackhandler());
 asyncClient.init(conf);
 asyncClient.start();
 asyncClient.startContainer(container, containerLaunchContext);
 [... wait for container being started]
 asyncClient.getContainerStatus(container.getId(), container.getNodeId(),
     container.getContainerToken());
 [... handle the status in the callback instance]
 asyncClient.stopContainer(container.getId(), container.getNodeId(),
     container.getContainerToken());
 [... wait for container being stopped]
 asyncClient.stop();
 }
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.NMClientAsync -->
</package>
<package name="org.apache.hadoop.yarn.client.api.async.impl">
</package>
<package name="org.apache.hadoop.yarn.client.api.impl">
</package>
<package name="org.apache.hadoop.yarn.client.cli">
  <!-- start class org.apache.hadoop.yarn.client.cli.LogsCLI -->
  <class name="LogsCLI" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.Tool"/>
    <constructor name="LogsCLI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="createYarnClient" return="org.apache.hadoop.yarn.client.api.YarnClient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="getAMContainerInfoForRMWebService" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="appId" type="java.lang.String"/>
      <exception name="ClientHandlerException" type="com.sun.jersey.api.client.ClientHandlerException"/>
      <exception name="UniformInterfaceException" type="com.sun.jersey.api.client.UniformInterfaceException"/>
      <exception name="JSONException" type="org.codehaus.jettison.json.JSONException"/>
    </method>
    <method name="getMatchedContainerLogFiles" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.logaggregation.ContainerLogsRequest"/>
      <param name="useRegex" type="boolean"/>
      <param name="ignoreSizeLimit" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getResponeFromNMWebService" return="com.sun.jersey.api.client.ClientResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="webServiceClient" type="com.sun.jersey.api.client.Client"/>
      <param name="request" type="org.apache.hadoop.yarn.logaggregation.ContainerLogsRequest"/>
      <param name="logFile" type="java.lang.String"/>
    </method>
    <method name="getNodeHttpAddressFromRMWebString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.logaggregation.ContainerLogsRequest"/>
      <exception name="ClientHandlerException" type="com.sun.jersey.api.client.ClientHandlerException"/>
      <exception name="UniformInterfaceException" type="com.sun.jersey.api.client.UniformInterfaceException"/>
      <exception name="JSONException" type="org.codehaus.jettison.json.JSONException"/>
    </method>
    <field name="HELP_CMD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.cli.LogsCLI -->
  <!-- start class org.apache.hadoop.yarn.client.cli.SchedConfCLI -->
  <class name="SchedConfCLI" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.Tool"/>
    <constructor name="SchedConfCLI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[CLI for modifying scheduler configuration.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.cli.SchedConfCLI -->
</package>
<package name="org.apache.hadoop.yarn.client.util">
</package>

</api>
