#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
1. Auto configure external python libraries like boto
2. Check environment variables 
3. Auto set up security group
4. Check whether to use AWS spot instance
5. Prepare necessary info for spot instance
"""

from __future__ import print_function, with_statement

import os
import sys
from sys import stderr
import argparse
import json
import tempfile
import errno

import boto
from boto import ec2
import yaml

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('provider')
    parser.add_argument('--is-aws-spot', action='store_true')
    parser.add_argument('--prepare-aws-spot', action='store_true')
    args = parser.parse_args()
    return args


def get_or_make_group(conn, name):
    groups = conn.get_all_security_groups()
    group = [g for g in groups if g.name == name]
    if len(group) > 0:
        return group[0]
    else:
        print("Creating security group {name} in {region}".format(name=name, region=conn.region))
        return conn.create_security_group(name, "Auto created by Tachyon deploy")


def set_security_group(conn, name):
    print("Setting up security group {} in {}".format(name, conn.region))
    sg = get_or_make_group(conn, name)
    if sg.rules != []:
        print('security group {} in {} already has rules, no modification will happen then'.format(name, conn.region))
        return
    proto = ['tcp', 'udp']
    authorized_ip = '0.0.0.0/0' # all IP
    for p in proto:
        sg.authorize(p, 0, 65535, authorized_ip)
 

def configure_aws(args):
    access_key = os.getenv('AWS_ACCESS_KEY_ID') 
    if access_key is None:
        print("ERROR: The environment variable AWS_ACCESS_KEY_ID must be set", 
                file=stderr)
        sys.exit(1)

    secret_key = os.getenv('AWS_SECRET_ACCESS_KEY') 
    if secret_key is None:
        print("ERROR: The environment variable AWS_SECRET_ACCESS_KEY must be set", 
                file=stderr)
        sys.exit(1)

    home=os.path.expanduser('~')
    boto_config_path = os.path.join(home, '.boto')
    with open(boto_config_path, 'w') as boto_config:
        boto_config.write('\n'.join([
            '[Credentials]', 
            'aws_access_key_id = ' + access_key, 
            'aws_secret_access_key = ' + secret_key]))

    ec2_conf = yaml.load(open('conf/ec2.yml'))
    region = ec2_conf['Region']
    sg = ec2_conf['Security_Group']

    try:
        conn = ec2.connect_to_region(region)
        print(conn.region)
    except Exception as e:
        print((e), file=stderr)
        sys.exit(1)
    set_security_group(conn, sg)


def is_aws_spot(ec2_conf):
    if ec2_conf['Spot_Price'] == "":
        print('false')
        return False
    else:
        print('true')
        return True


def mkdir_p(path):
    """mkdir -p"""
    try:
        os.makedirs(path)
    except OSError as e:
        if not e.errno == errno.EEXIST:
            raise


def trans_to_volume(device):
    volume = {}
    volume['device_name'] = device['DeviceName']
    if device['VirtualName'].startswith('ephemeral'):
        # instance storage
        volume['ephemeral'] = device['VirtualName']
    else:
        # EBS
        volume['volume_size'] = device['Ebs.VolumeSize']
        delete = device.get('Ebs.DeleteOnTermination', None)
        if delete is not None:
            volume['delete_on_termination'] = delete
    return volume


def create_aws_spot_vars(ec2_conf):
    init = yaml.load(open("conf/init.yml"))
    var = {
        'zone':           ec2_conf["Availability_Zone"],
        'count':          init["MachineNumber"],
        'image':          ec2_conf["AMI"],
        'region':         ec2_conf["Region"],
        'volumes':        map(trans_to_volume, ec2_conf["Block_Device_Mapping"]),
        'key_name':       ec2_conf["Keypair"],
        'spot_price':     ec2_conf["Spot_Price"],
        'instance_type':  ec2_conf["Instance_Type"],
        'security_group': ec2_conf["Security_Group"],

        'temp_folder':    tempfile.mkdtemp(), # temporary folder for ansible to save info
    }
    var_dir = 'spot/roles/create_ec2/vars'
    mkdir_p(var_dir)
    out = open(os.path.join(var_dir, 'main.yml'), 'w')
    yaml.dump(var, out, default_flow_style=False)
    out.close()


def create_inventory_id_and_tags(ec2_conf, ec2_info):
    # mock the inventory and ids that should be generated by vagrant
    inventory_dir = '.vagrant/provisioners/ansible/inventory'
    mkdir_p(inventory_dir)
    inventory = open(os.path.join(inventory_dir, 'vagrant_ansible_inventory'), 'w')

    machine_dir = '.vagrant/machines'
    mkdir_p(machine_dir)

    tag = ec2_conf['Tag']
    tags = {}
    for i, instance in enumerate(ec2_info['instances']):
        host = "TachyonMaster" if i == 0 else "TachyonWorker{id}".format(id=i)
        inventory.write("{host} ansible_ssh_host={ip} ansible_ssh_port=22\n".format(host=host, ip=instance['public_ip']))

        instance_id = str(instance['id'])
        id_dir = os.path.join(machine_dir, host, 'aws')
        mkdir_p(id_dir)
        with open(os.path.join(id_dir, 'id'), 'w') as f:
            f.write(instance_id)

        tags[instance_id] = '{tag}-{host}'.format(tag=tag, host=host)

    inventory.close()

    # map instance id to its tag
    spot_tag_dir = 'spot/roles/tag_ec2/vars'
    mkdir_p(spot_tag_dir)
    tag_vars = open(os.path.join(spot_tag_dir, 'main.yml'), 'w')
    var = {
        "tags": tags,
        "region": ec2_conf["Region"],
    }
    yaml.dump(var, tag_vars, default_flow_style=False)
    tag_vars.close()


if __name__ == '__main__':
    args = parse_args()
    if args.provider == 'aws' and args.is_aws_spot:
        ec2_conf = yaml.load(open('conf/ec2.yml'))
        is_spot = is_aws_spot(ec2_conf)
        if is_spot:
            create_aws_spot_vars(ec2_conf)
    elif args.provider == 'aws' and args.prepare_aws_spot:
        temp_folder = yaml.load(open('spot/roles/create_ec2/vars/main.yml'))['temp_folder']
        ec2_info = json.load(open(os.path.join(temp_folder, 'ec2.info')))
        ec2_conf = yaml.load(open('conf/ec2.yml'))
        create_inventory_id_and_tags(ec2_conf, ec2_info)
    elif args.provider == 'aws':
        configure_aws(args)

